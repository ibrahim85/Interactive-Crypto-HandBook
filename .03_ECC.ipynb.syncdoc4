{"notebook_name":"03_ECC.ipynb"}
"## ECC\nThere are some great article that you may take a look: http://andrea.corbellini.name/tag/ecc/ , https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture14.pdf , \n\nWith elliptic curves, we have two types of operations that we generally want to accomplish:\n\n- Digital signatures are the public key equivalent of message authentication codes. Alice signs a document using her private key, and users verify the signature against her public key.\n- Encryption with elliptic curves is done by performing a key exchange. Alice uses a function called elliptic curve Diffie-Hellman (ECDH) to generate a shared key to encrypt messages to Bob.\n\nThere are three curves we generally use with elliptic curve cryptography:\n\n- the NIST P256 curve, which is equivalent to an AES-128 key (also known as secp256r1)\n- the NIST P384 curve, which is equivalent to an AES-192 key (also known as secp384r1)\n- the NIST P521 curve, which is equivalent to an AES-256 key (also known as secp521r1)\n\nAlternatively, there is the Curve25519 curve, which can be used for key exchange, and the Ed25519 curve, which can be used for digital signatures."︡{"metadata":{"collapsed":false,"trusted":false},"cell_type":"markdown"}
"### Generating Keys\n\nGenerating new keys with PyElliptic is done with the ECC class. As we used AES-256 previously, we’ll use P521 here."︡{"metadata":{},"cell_type":"markdown"}
"import pyelliptic\ndef generate_key():\n     return pyelliptic.ECC(curve='secp521r1')"︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"code","execution_count":1,"outputs":[]}
"Public and private keys can be exported (i.e. for storage) using the accessors (the examples shown are for Python 2)."︡{"metadata":{},"cell_type":"markdown"}
"curve = generate_key()\npriv = curve.get_privkey()\npub = curve.get_pubkey()"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":2,"outputs":[]}
"The keys can be imported when instantiating a instance of the ECC class"︡{"metadata":{},"cell_type":"markdown"}
"### Signing Messages\n\nNormally when we do signatures, we compute the hash of the message and sign that. PyElliptic does this for us, using SHA-512. Signing messages is done with the private key and some message. The algorithm used by PyElliptic for signatures is called ECDSA."︡{"metadata":{},"cell_type":"markdown"}
"def sign(key, msg):\n    \"\"\"Sign a message with the ECDSA key.\"\"\"\n    return key.sign(msg)"︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"code","execution_count":3,"outputs":[]}
"In order to verify a message, we need the public key for the signing key, the message, and the signature. We’ll expect a serialised public key and perform the import to a pyelliptic.ecc.ECC instance internally."︡{"metadata":{},"cell_type":"markdown"}
"def verify(pub, msg, sig):\n    \"\"\"Verify the signature on a message.\"\"\"\n    return pyelliptic.ECC(curve='secp521r1', pubkey=pub).verify(sig, msg)"︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"code","execution_count":4,"outputs":[]}
"### Encryption\n\nUsing elliptic curves, we encrypt using a function that generates a symmetric key using a public and private key pair. The function that we use, ECDH (elliptic curve Diffie-Hellman), works such that:"︡{"metadata":{},"cell_type":"markdown"}
"That is, ECDH with Alice’s private key and Bob’s public key returns the same shared key as ECDH with Bob’s private key and Alice’s public key.\nWith pyelliptic, the private key used must be an instance of pyelliptic.ecc.ECC; the public key must be in serialised form."︡{"metadata":{},"cell_type":"markdown"}
"shared_key = curve.get_ecdh_key(pub)\nlen(shared_key)"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":5,"outputs":[{"output_type":"execute_result","data":{"text/plain":"32"},"metadata":{},"execution_count":5}]}
"def shared_key(curve, pub):\n    \"\"\"Generate a new shared encryption key from a keypair.\"\"\"\n    shared_key = curve.get_ecdh_key(pub)\n    return shared_key"︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"code","execution_count":6,"outputs":[]}
"### Ephemeral keys\n\nFor improved security, we should use ephemeral keys for encryption; that is, we generate a new elliptic curve key pair for each encryption operation. This works as long as we send the public key with the message. Let’s look at a sample EC encryption function. For this function, we need the public key of our recipient, and we’ll pack our key into the beginning of the function. This method of encryption is called the elliptic curve integrated encryption scheme, or ECIES. (or more precise the key exchange is on the fly, so is ECDHE)"︡{"metadata":{},"cell_type":"markdown"}
"import struct\nimport Crypto.Random.OSRNG.posix as RNG\nimport Crypto.Cipher.AES as AES \n__AES_KEYLEN = 32\n\ndef generate_nonce():\n    \"\"\"Generate a random number used once.\"\"\"\n    return RNG.new().read(AES.block_size)\n\ndef pad_data(data):\n    \"\"\"pad_data pads out the data to an AES block length.\"\"\"\n    # return data if no padding is required\n    if len(data) % 16 == 0:\n        return data\n\n    # subtract one byte that should be the 0x80\n    # if 0 bytes of padding are required, it means only\n    # a single \\x80 is required.\n\n    padding_required = 15 - (len(data) % 16)\n\n    data = '%s\\x80' % data\n    data = '%s%s' % (data, '\\x00' * padding_required)\n\n    return data\n\ndef unpad_data(data):\n    \"\"\"unpad_data removes padding from the data.\"\"\"\n    if not data:\n        return data\n\n    data = data.rstrip('\\x00')\n    if data[-1] == '\\x80':\n        return data[:-1]\n    else:\n        return data\n\ndef encrypt_02(data, key):\n     \"\"\"\n     Encrypt data using AES in CBC mode. The IV is prepended to the\n     ciphertext.\n     \"\"\"\n     data = pad_data(data)\n     ivec = generate_nonce()\n     aes = AES.new(key, AES.MODE_CBC, ivec)\n     ctxt = aes.encrypt(data)\n     return ivec + ctxt\n \n \ndef decrypt_02(ciphertext, key):\n     \"\"\"\n     Decrypt a ciphertext encrypted with AES in CBC mode; assumes the IV\n     has been prepended to the ciphertext.\n     \"\"\"\n     if len(ciphertext) <= AES.block_size:\n         raise Exception(\"Invalid ciphertext.\")\n     ivec = ciphertext[:AES.block_size]\n     ciphertext = ciphertext[AES.block_size:]\n     aes = AES.new(key, AES.MODE_CBC, ivec)\n     data = aes.decrypt(ciphertext)\n     return unpad_data(data)\n\n\ndef encrypt(pub, msg):\n    \"\"\"\n    Encrypt the message to the public key using ECIES. The public key\n    should be a serialised public key.\n    \"\"\"\n    ephemeral = generate_key() # Alice's private key\n    key = shared_key(ephemeral, pub) #symmetric key derives from ECDH(alice_priv, bob_pub)\n    ephemeral_pub = struct.pack('>H', len(ephemeral.get_pubkey()))\n    ephemeral_pub += ephemeral.get_pubkey() # Alice's public key\n    return ephemeral_pub+encrypt_02(msg, key)"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":7,"outputs":[{"output_type":"stream","text":"/projects/sage/sage-6.10/local/lib/python2.7/site-packages/Crypto/Util/number.py:57: PowmInsecureWarning: Not using mpz_powm_sec.  You should rebuild using libgmp >= 5 to avoid timing attack vulnerability.\n  _warn(\"Not using mpz_powm_sec.  You should rebuild using libgmp >= 5 to avoid timing attack vulnerability.\", PowmInsecureWarning)\n","name":"stderr"}]}
"Encryption packs the public key at the beginning, writing first a 16-bit unsigned integer containing the public key length and then appending the ephemeral public key and the ciphertext to this. Decryption needs to unpack the ephemeral public key (by reading the length and extracting that many bytes from the message) and then decrypting the message with the shared key."︡{"metadata":{},"cell_type":"markdown"}
"def decrypt(priv, msg):\n    \"\"\"\n    Decrypt an ECIES-encrypted message with the private key.\n    \"\"\"\n    ephemeral_len = struct.unpack('>H', msg[:2])[0]\n    ephemeral_pub = msg[2:2+ephemeral_len] # Alice's public key\n    key = shared_key(priv, ephemeral_pub) #symmetric key derives from ECDH(bob_priv, alice_pub)\n    return decrypt_02(msg[2+ephemeral_len:], key)"︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"code","execution_count":8,"outputs":[]}
"curve = generate_key()\npub  = curve.get_pubkey()\nplaintext = 'AG is god'\nciphertext = encrypt(pub, plaintext)"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":9,"outputs":[]}
"print decrypt(curve, ciphertext)"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":10,"outputs":[{"output_type":"stream","text":"AG is god\n","name":"stdout"}]}
"curve = generate_key()\ncurve.get_pubkey()"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":19,"outputs":[{"output_type":"execute_result","data":{"text/plain":"'\\x04\\x00\\xeb\\xeed\\xd9D\\xf4Fc\\xd3 \\xc29\\x82\\x81\\x00:\\x87\\xe7ya\"\\xb26\\xd4f\\xca\\x03XE)\\x8dH\\x88=\\x02#_\\xc8\"\\xceZ\\x08#\\x16\\xe6:K\\xa2]E\\x864f5<\\xb2\\x8e\\xd1\\xd6\\x9b<\\x93\\x11\\x90r\\x01DTmhU\\xb5\\xee\\xac\\xe5\\x83O\\xe7}J\\x88\\xeak\\x1dj\\x8a\\x9a\\xd7\\x98\\x1a\\x95\\xa0{>?\\xb1_\\x11\\xd3:\\x9bBI\\xa7u\\xc2\\xc9Xi\\xb8;\\xa8j\\x96\\xd2v+zW\\xf9w;FhIm\\xc5\\x1b9\\x0e%'"},"metadata":{},"execution_count":19}]}
"curve = generate_key()\ncurve.get_pubkey()"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":20,"outputs":[{"output_type":"execute_result","data":{"text/plain":"\"\\x04\\x01\\xb8\\x0e\\xc7\\xd2\\xd7\\xcb\\xe6\\r\\xbb\\x97NY\\xed+\\xfa\\x96\\xfa\\xc3\\x8b\\xd8Y\\x9c\\xf0\\x81\\x8bD\\xff\\x9a\\x89\\x01\\xe2\\x85\\xf9{\\x8eu{\\xc58Q\\x12/B\\xbd\\n(\\x1e\\x88\\x1a\\x18\\x17\\xf0\\xd6KR\\xa4B\\x83\\xaas\\xbf\\x93`q\\x9b\\x00\\xb8j\\xe8\\xc1\\xe9W\\x94\\x87w\\xfek\\x1aE\\x03\\xe6u\\x0c=]\\xe7\\x1f\\x80'W\\xf0\\xfd!\\xc3\\x18\\xf3\\xcf\\xbfC~z\\xd4lZI\\xe5\\xc9\\xa5]j\\x19I\\\\\\x86 \\x849\\x1d_B\\x05'\\xfd\\xccoCHm\\x92\\x122\""},"metadata":{},"execution_count":20}]}
"### Key Exchange\n\nSo how does Bob know the key actually belongs to Alice? There are two main schools of thought regarding the authentication of key ownership: centralised and decentralised. \n\nTLS/SSL follow the centralised school: a root certificate1 authority (CA) signs intermediary CA keys, which then sign user keys. For example, Bob can generate an SSL keypair. From this, he generates a certificate signing request, and sends this to the CA. The CA, usually after taking some money and ostensibly actually verifying Bob’s identity, then signs Bob’s certificate. Bob sets up his webserver to use his SSL certificate for all secure traffic, and Alice sees that the CA did in fact sign his certificate. This relies on trusted central authorities, Alice’s web browser would ship with a keystore of select trusted CA public keys (like VeriSigns) that she could use to verify signatures on the certificates from various sites. This system is called a public key infrastructure. \n\nThe other school of thought is followed by PGP - the decentralised model. In PGP, this is manifested as the Web of Trust. For example, if Carol now wants to talk to Bob and gives Bob her public key, Bob can check to see if Carol’s key has been signed by anyone else. We’ll also say that Bob knows for a fact that Alice’s key belongs to Alice, and he trusts her, and that Alice has signed Carol’s key. Bob sees Alice’s signature on Carol’s key and then can be reasonably sure that Carol is who she says it was. If we repeat the process with Dave, whose key was signed by Carol (whose key was signed by Alice), Bob might be able to be more certain that the key belongs to Dave, but maybe he doesn’t really trust Carol to properly verify identities. Bob can mark keys as having **various trust levels**, and from this a web of trust emerges: a picture of how well you can trust that a given key belongs to a given user.\n\nThe key distribution problem is not a quick and easy problem to solve; There are key exchange protocols (such as the Diffie-Hellman key exchange and IKE (which uses Diffie-Hellman) that provide alternatives to the web of trust and public key infrastructures."︡{"metadata":{},"cell_type":"markdown"}
"import binascii\n# Asymmetric encryption\nalice = pyelliptic.ECC() # default curve: sect283r1\nbob = pyelliptic.ECC(curve='sect571r1')\n\nciphertext = alice.encrypt(\"Hello Bob\", bob.get_pubkey(),\n                           ephemcurve='sect571r1')\nprint(bob.decrypt(ciphertext))\n\nsignature = bob.sign(\"Hello Alice\")\n# alice's job :\nprint(pyelliptic.ECC(pubkey=bob.get_pubkey(),\n                     curve='sect571r1').verify(signature, \"Hello Alice\"))\n\n# ERROR !!!\ntry:\n    key = alice.get_ecdh_key(bob.get_pubkey())\nexcept:\n    print(\"For ECDH key agreement, the keys must be defined on the same curve !\")\n\nalice = pyelliptic.ECC(curve='sect571r1')\nprint(binascii.hexlify(alice.get_ecdh_key(bob.get_pubkey())))\nprint(binascii.hexlify(bob.get_ecdh_key(alice.get_pubkey())))"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":16,"outputs":[{"output_type":"stream","text":"Hello Bob\nTrue\nFor ECDH key agreement, the keys must be defined on the same curve !\n07a2558b289740048ca45ff31a4522b1dbd4226214d1a8c602cb76bc52833d1f\n07a2558b289740048ca45ff31a4522b1dbd4226214d1a8c602cb76bc52833d1f\n","name":"stdout"}]}
""︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"code","execution_count":null,"outputs":[]}