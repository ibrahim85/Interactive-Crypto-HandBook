{"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.4.3+"},"name":"04_Pairing.ipynb"}
{"cell_type":"markdown","metadata":{},"source":"## Pairing Based Cryptography\n\n要implement此類crypto至少需要以下計算:\n\n1. Arithmetic in $Z_p$: 可以建構在 GMP library 上 (提供了 number theoretic functions 像是 inversion modulo a prime 和  Jacobi symbol 等)\n\n2. Elliptic curve groups: 解 $y^2=x^3+ax+b over Zp$, point addition 和 multiplication (可參考前一份notebook)\n\n3. Bilinear pairing: Miller’s algorithm\n\n上述可以實現出 Type A and B (and A1) pairings- 快速但是elements 需要很多空間來表示，如果要實現起他 pairing 就必須實現 Field extensions  \n\n> 另外還要尋找 pairing-friendly curves。 像是 MNT curve construction method 需要 finding roots modulo a given prime, testing polynomial irreducibility, computing Hilbert polynomials. 這些都需要 high precision complex floating point arithmetic 和解 Pell-type equation\n\n> 另外我們要隨機在 elliptic curve 上產生點，常見做法是隨機選擇 x-coordinate 然後解上述的 quadratic equation 來得到 y. (若無解， 則再換下一個x座標)。對於 odd characteristics， 如果我們可以找到 square roots of elements這可以一次達成。 在 finite field of prime order 中 square roots 可以藉由解 Tonelli-Shanks algorithm來得到。 至於其他field 則要參考其他新的文獻。(一個解法是去解 $x^2−a$ 用 Cantor-Zassenhaus method (Legendre’s method))。\n\n> 對於特定情況有更簡潔的方式可以產生隨機點。 例如若 p 是質數且 $p = 2 \\pmod 3 $ 則 x 的三次方根(Fq中) 為 $x^{(2p−1)/3}$. 故若方程式中 a=0，我們可以選擇先挑y然後解x。"}
{"cell_type":"markdown","metadata":{},"source":"## Introduction to Charm"}
{"cell_type":"markdown","metadata":{},"source":"### Group Abstractions\n\n實做scheme的第一步是去選擇適當的 group。 Modern cryptographic algorithms 通常建構在提供特定數學難題性質的group上。\n\n在charm中提供了三種cryptographic settings：\n1. Integergroups\n2. ecgroups\n3. pairinggroups\n\n要 initialize a group in the elliptic curve (EC) setting, 請參考 toolbox.eccurve 中實做的成員和方法以及了解提供相關的 NIST approved curves (e.g., prime192v1). \n\n對 EC with billinear maps (or pairings)來說，提供了 symmetric 和 asymmetric 的 curves。 例如: 'SS512' 是一個 symmetric curve with a 512-bit base field 而'MNT159' 代表了 asymmetric curve with 159-bit base field. \n\n> 注意這些 curves 是 **prime order**。\n\n最後，對於 Integer groups, 通常定義大質數 p and q 就足以產生一個 RSA group. 若要用其他像 schnorr groups, 可能會需要一些時間來產生相關參數，因為 **他們要求safe primes (例如: p = 2q + 1)**. 接下來我們呈現 integer 和 pairing groups:"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"from charm.toolbox.integergroup import IntegerGroup"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"group1 = IntegerGroup()\ngroup1.paramgen(1024)\n\ng = group1.randomGen()\ng, type(g)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"dir(g)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"from charm.toolbox.pairinggroup import PairingGroup,ZR,G1,G2,GT,pair"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"group2 = PairingGroup('SS512')\ng1 = group2.random(G1)\ng2 = group2.random(G2)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"g1, g2, type(g1)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"help(g1)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"type(g2)"}
{"cell_type":"markdown","metadata":{},"source":"### Implement a Scheme\n\n通常採用OOP的實作方法來增進可重複利用以及延伸性。 事實上內建了許多 base classes 對許多 cryptographic primitives 含有 standard interfaces 像是 PKEnc(public-key encryption)， PKSig(public-key signatures)， ABEnc(attribute-based encryption) 等等。**第一步是去繼承這些class** (下面我們說明如何用 Charm 實現 Cramer-Shoup PKEnc scheme。)\n\n> 在 charm toolbox 中每種 cryptographic setting 有一個對應的 group abstraction 像是前面提到的 elliptic curve group , pairing group, 和 integer groups。 這些 abstractions 提供了 convenient 且 simple 的界面來選擇 group parameters, 運算 group operations, 和 benchmarking.\n\n接下來，針對所要實現的 cryptographic scheme **要 import 我們要實現相關的 group setting**。\n\n在 class initialization時，會呼叫 __init__， 在這個例子中會定義PKEnc基本的 security properties: 把 NIST standard elliptic curve identifier當成input。另外， 在這例子中，我們將 group object 定義為 global variable. \n\n> 另一種方法是定義 group 為class member，例如: self.group = ECGroup(curve)."}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"from charm.toolbox.PKEnc import PKEnc\nfrom charm.toolbox.ecgroup import ECGroup\n\nclass CS98(PKEnc):\n    def __init__(self, curve):\n        PKEnc.__init__(self)\n        global group\n        group = ECGroup(curve)"}
{"cell_type":"markdown","metadata":{},"source":"接下來看 Keygen， 他只接受一個 security parameter，然後產生 public 和 private keys 給 user， 注意這邊我們需要選一個 hash function H\n\n$\\begin{array}{c}\n    g_1, g_2 \\in G \\\\\n    x_1, x_2, y_1, y_2, z \\in Z_q \\\\\n    c = g_1^{x_1} \\cdot g_2^{x_2}, d = g_1^{y_1} \\cdot g_2^{y_2}, h = g_1^z \\\\\n    pk = (g_1, g_2, c, d, h, H) \\\\\n    sk = (x_1, x_2, y_1, y_2, z)\n\\end{array}$"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def keygen(self, secparam): # Security parameter only\n    g1, g2 = group.random(G), group.random(G)\n    x1, x2, y1, y2, z = group.random(ZR), group.random(ZR), group.random(ZR), group.random(ZR), group.random(ZR)\n    c = (g1 ** x1) * (g2 ** x2)\n    d = (g1 ** y1) * (g2 ** y2)\n    h = (g1 ** z)\n\n    pk = { 'g1' : g1, 'g2' : g2, 'c' : c, 'd' : d, 'h' : h, 'H' : group.hash } #dict class\n    sk = { 'x1' : x1, 'x2' : x2, 'y1' : y1, 'y2' : y2, 'z' : z }\n    return (pk, sk)"}
{"cell_type":"markdown","metadata":{},"source":"encryption 在 paper中敘述如下，我們利用group的encode幫我們轉換message到運算domain\n\n$\\begin{array}{c}\n    m \\in G, r \\in Z_q \\\\\n    u_1 = g_1^r, u_2 = g_2^r, e = h^r \\cdot m , \\alpha = H(u_1, u_2, e), v = c^r \\cdot d^{r\\alpha} \\\\\n    (u_1, u_2, e, v) \n\\end{array}$"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def encrypt(self, pk, m):\n    r   = group.random(ZR)\n    u1  = pk['g1'] ** r\n    u2  = pk['g2'] ** r\n    e   = group.encode(m) * (pk['h'] ** r)\n    alpha = pk['H'](u1, u2, e)\n    v   = (pk['c'] ** r) * (pk['d'] ** (r * alpha))\n\n    return { 'u1' : u1, 'u2' : u2, 'e' : e, 'v' : v }"}
{"cell_type":"markdown","metadata":{},"source":"decryption 在 paper中敘述如下\n\n$\\begin{array}{c}\n    \\alpha = H(u_1, u_2, e) \\\\\n    v = u_1^{x_1+y_1\\alpha} \\cdot u_2^{x_2+y_2\\alpha} \\\\\n    m = e/{u_1^z} \n\\end{array}$"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def decrypt(self, pk, sk, c):\n    alpha = pk['H'](c['u1'], c['u2'], c['e'])\n\n    v_prime = (c['u1'] ** (sk['x1'] + (sk['y1'] * alpha))) * (c['u2'] ** (sk['x2'] + (sk['y2'] * alpha)))\n    if (c['v'] != v_prime):\n        return 'reject'\n    return group.decode(c['e'] / (c['u1'] ** sk['z']))"}
{"cell_type":"markdown","metadata":{},"source":"這類scheme會將 messages 定義為 group element，故我們利用charm內建的 encode/decode methods 來將message轉換進入 G。 然而目前沒有支援直接轉進pairing group的 encode/decode。 因此將用別種方式來替代直接轉換"}
{"cell_type":"markdown","metadata":{},"source":"## Reuse Tools\n先在這邊找找看有沒有可用的工具吧! https://jhuisi.github.io/charm/toolbox.html#toolbox"}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"### Test and Benchmark\n設計好shceme之後需要做驗證和量測performance。 charm提供了兩個 approaches: \n\n- Define a test routine that executes the algorithms in your scheme via test vectors if they exist a\n- **embedding the test routine as a docstring in your scheme’s class definition**. \n\n> Docstrings 可用下列方法直接執行! ``python -m doctest myScheme.py``\n\n另外有下列benchmark flag可以使用: **RealTime, CpuTime, Add, Sub, Mul, Div, and Exp**. 以下是對 EC setting 使用 Charm 的 benchmark interface"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"from charm.toolbox.ecgroup import ECGroup,ZR,G\nfrom charm.toolbox.eccurve import prime192v1\n\ntrials = 10\ngroup = ECGroup(prime192v1)\ng = group.random(G)\nh = group.random(G)\ni = group.random(G)\n\nassert group.InitBenchmark(), \"failed to initialize benchmark\"\ngroup.StartBenchmark([\"Mul\", \"Div\", \"Exp\", \"Granular\"])\nfor a in range(trials):\n    j = g * h\n    k = h ** group.random(ZR)\n    t = (j ** group.random(ZR)) / k\ngroup.EndBenchmark()\n\nmsmtDict = group.GetGeneralBenchmarks()\nprint (\"<=== General Benchmarks ===>\")\nprint (\"Mul := \", msmtDict[\"Mul\"])\nprint (\"Div := \", msmtDict[\"Div\"])\nprint (\"Exp := \", msmtDict[\"Exp\"])\ngranDict = group.GetGranularBenchmarks()\nprint (\"<=== Granular Benchmarks ===>\")\nprint (\"G mul   := \", granDict[\"Mul\"][G])\nprint (\"G exp   := \", granDict[\"Exp\"][G])"}
{"cell_type":"markdown","metadata":{},"source":"以上的 benchmark function 也可以用在其他的 group settings。 pairing base module同樣支援 **granular level (operation count per group)**的 benchmark。 如下:"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"from charm.toolbox.pairinggroup import PairingGroup,ZR,G1,G2,GT,pair\n\ntrials = 10\ngroup = PairingGroup(\"SS1024\")\ng = group.random(G1)\nh = group.random(G1)\ni = group.random(G2)\n\nassert group.InitBenchmark(), \"failed to initialize benchmark\"\ngroup.StartBenchmark([\"Mul\", \"Exp\", \"Pair\", \"Granular\"])\nfor a in range(trials):\n    j = g * h\n    k = i ** group.random(ZR)\n    t = (j ** group.random(ZR)) / h\n    n = pair(h, i)\ngroup.EndBenchmark()\n\nmsmtDict = group.GetGeneralBenchmarks()\ngranDict = group.GetGranularBenchmarks()\nprint(\"<=== General Benchmarks ===>\")\nprint(\"Results  := \", msmtDict)\nprint(\"<=== Granular Benchmarks ===>\")\nprint(\"G1 mul   := \", granDict[\"Mul\"][G1])\nprint(\"G2 exp   := \", granDict[\"Exp\"][G2])"}
{"cell_type":"markdown","metadata":{},"source":"另外針對 integer module， 我們可以 benchmarking without a group object:"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"from charm.core.math.integer import *\ntrials = 10\na = integer(1234)\n\nassert InitBenchmark(), \"failed to initialize benchmark\"\nStartBenchmark([\"RealTime\", \"Exp\", \"Mul\"])\nfor k in range(trials):\n    r = randomPrime(512)\n    s = r * (r ** a)\n    j = r * (r ** a)\nEndBenchmark()\n\nmsmtDict1 = GetGeneralBenchmarks()\nprint (\"General Benchmarks: \", msmtDict1)"}
{"cell_type":"markdown","metadata":{},"source":"## Optimization\n針對 pairing base module， charm提供了 pre-computation tables 來加速 group exponentiation。 要使用的話，先呼叫 `initPP()` method 在 pairing object in G1, G2, or GT 上。 `initPP()` 會儲存 pre-computed values。 見以下比較10次 exponential 有用和沒有用的差別"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"from charm.toolbox.pairinggroup import PairingGroup,ZR,G1,G2,GT,pair\n\ncount = 10\ngroup = PairingGroup(\"MNT224\")\ng = group.random(GT)\nassert g.initPP(), \"failed to init pre-computation table\"\nh = group.random(GT)\na, b = group.random(ZR, 2)\n\nassert group.InitBenchmark(), \"failed to initialize benchmark\"\ngroup.StartBenchmark([\"RealTime\"])\nfor i in range(count):\n    A = g ** a\ngroup.EndBenchmark()\nprint (\"With PP: \", group.GetBenchmark(\"RealTime\"))\n\n\n\nassert group.InitBenchmark(), \"failed to initialize benchmark\"\ngroup.StartBenchmark([\"RealTime\"])\nfor i in range(count):\n    B = h ** b\ngroup.EndBenchmark()\nprint (\"Without: \", group.GetBenchmark(\"RealTime\"))"}
{"cell_type":"markdown","metadata":{},"source":"## Implement Application\n\n拉高一個 abstraction level 來看，我們可以在應用中拿內建的sheme(https://jhuisi.github.io/charm/schemes.html#schemes)。 每一個內建scheme都有example的main function吃 default的test。 因此我們可以看main來了解如何使用它， 底下為在application中使用 Cramer-Shoup scheme:"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"from charm.schemes.pkenc.pkenc_cs98 import CS98\nfrom charm.toolbox.eccurve import prime192v1\nfrom charm.toolbox.ecgroup import ECGroup\n\ngroupObj = ECGroup(prime192v1)\npkenc = CS98(groupObj)\n\n(pk, sk) = pkenc.keygen()\n\nM = b'Hello World!'\nciphertext = pkenc.encrypt(pk, M)\n\nmessage = pkenc.decrypt(pk, sk, ciphertext)\n(ciphertext, message)"}
{"cell_type":"markdown","metadata":{},"source":"### Serial API\n為了支援 key或 ciphertext的 serialization，charm toolbox 中提供了兩個 high-level API 來 serialize charm objects (和 python structures (e.g., lists, tuples, or dictionaries, etc)做轉換) 亦即`charm.core.engine.util` packag 中的 `objectToBytes()` 和 `bytesToObject()`。 這些function可以將 keys 和 ciphertexts 轉換成 **base 64 encoded strings**。\n\n以下說明如何使用 upported group objects (integergroup, pairinggroup or ecgroup)的這個 API:\n\n```\nfrom charm.core.engine.util import objectToBytes,bytesToObject\n\npk_bytes = objectToBytes(pk, group)\norig_pk = bytesToObject(pk_bytes, group)\n```"}
{"cell_type":"markdown","metadata":{},"source":"若想要加入 custom serialization routine，以下說明 schemes based on the integergroup 如何在不需要 group object下達成:"}
{"cell_type":"markdown","metadata":{},"source":"```\nfrom charm.core.math.integer import integer,serialize,deserialize\n\nclass mySerializeAPI:\n        def __init__(self)\n                ...\n\n        def serialize(self, charm_object):\n            assert type(charm_object) == integer, \"required type is integer, not: \", type(charm_object)\n            return serialize(charm_object)\n\n        def deserialize(self, object):\n            assert type(object) == bytes, \"required type is bytes, not: \", type(object)\n            return deserialize(object)\n\nfrom charm.core.engine.util import objectToBytes,bytesToObject\n\nserObject = mySerializeAPI()\npk_bytes = objectToBytes(pk, serObject)\norig_pk = bytesToObject(pk_bytes, serObject)\n```"}
{"cell_type":"markdown","metadata":{},"source":"## ABE example"}
{"cell_type":"code","execution_count":6,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Attributes => ['THREE', 'ONE', 'TWO']\nPolicy => ((ONE or THREE) and (ONE or FOUR))\nsk :=> {'Djp': {'THREE': [6276122109109426287397553513575914468341027484366298497746300064132749253539980029132700773775447955442676300956836137281382181372546499724557459973369490, 1795476119287768441013887569705620933962494299668997391846792068958141096175304165244965706342723260232250086876889100253742624870810067037151552353031807], 'TWO': [6924124382980575830781490840630960273794342008751116574070665252364212195636192550742824655262852541846254965051425217574882536637642592616612155973395808, 8108426394656279258614966091821611038675838157480563425712989481381530945904325372340963087983567673593458303309907998087951849442207502323531761728168001], 'ONE': [6214922806147845959328072463238677155640067392726266903682243783876099942600904104773748970444727984510062636495191147198345655765522974854475074699791359, 4630962608250885034549832054036011242006941950537077468772236052050884033803703912105524225739004590799163049382175163833868849228617070716457437315420126]}, 'S': ['THREE', 'ONE', 'TWO'], 'D': [7687491133591300392489925937356671817531456966061948916229208833518845082633339153261975594982026586415308356033055153604299653858595474432396275243773000, 4318950466636556312032265562625647492326724869289831129174893034346195323582587562433111119245156322042479243840555644418535798917990151942743847383780563], 'Dj': {'THREE': [7994613409051727137522865580015029574772996843380828301599887126273613132844122913337590146469959657539996722785678494558443433149046454112274017506093854, 3905999273369170389289588280376602134461333515823066665811835708384759635246475375865644058077196138036701150784678481263701897912740609436813254212907645], 'TWO': [5035495247163564172284577618592484581014067962687230501105497707767536697578968095496011419373642480182091229748882502794990229017892287271693747171642159, 7768591754299435361319796433922437420175007293702926461217826123671734856797194686197706260013527009051827951196910300017586416653757940260645394794756086], 'ONE': [6805189749535456001264102735047759589342626779139275815700412176233753702347101696333559080054586606548573296648525732185009932900151431864903264736086416, 6695605871674387402119430197165256691216959425906221313196935410770986832136369820089136314801454730884042011993618575113141067457071896178035126718084789]}}\nmsg => [5499530206739178687329483066235619442931659699977981155680587241526012324791607903651765803548056374589854867322721271855880337977684419674241327412344022, 1586884519471378212390281522967903086724330382922390165640139288304416399438221420818991375092282769535787961108438238586764989210068394126794331160644798]\n\n\nCiphertext...\n\n\n\nDecrypt...\n\nRec msg => [5499530206739178687329483066235619442931659699977981155680587241526012324791607903651765803548056374589854867322721271855880337977684419674241327412344022, 1586884519471378212390281522967903086724330382922390165640139288304416399438221420818991375092282769535787961108438238586764989210068394126794331160644798]\nSuccessful Decryption!!!\n"}],"source":"from charm.schemes.abenc.abenc_bsw07 import CPabe_BSW07\nfrom charm.toolbox.pairinggroup import PairingGroup,GT\n\ndebug = True\ngroupObj = PairingGroup('SS512')\n\ncpabe = CPabe_BSW07(groupObj)\nattrs = ['THREE', 'ONE', 'TWO']\naccess_policy = '((ONE or THREE) and (ONE or FOUR))'\nif debug:\n    print(\"Attributes =>\", attrs); print(\"Policy =>\", access_policy)\n\n(pk, mk) = cpabe.setup()\n\nsk = cpabe.keygen(pk, mk, attrs)\nprint(\"sk :=>\", sk)\n\nrand_msg = groupObj.random(GT)\nif debug: print(\"msg =>\", rand_msg)\nct = cpabe.encrypt(pk, rand_msg, access_policy)\n\nif debug: print(\"\\n\\nCiphertext...\\n\")\ngroupObj.debug(ct)\n\nrec_msg = cpabe.decrypt(pk, sk, ct)\nif debug: print(\"\\n\\nDecrypt...\\n\")\nif debug: print(\"Rec msg =>\", rec_msg)\n\nassert rand_msg == rec_msg, \"FAILED Decryption: message is incorrect\"\nif debug: print(\"Successful Decryption!!!\")"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"from charm.toolbox.pairinggroup import PairingGroup,ZR,G1,G2,GT,pair\nfrom charm.toolbox.secretutil import SecretUtil\nfrom charm.toolbox.ABEnc import ABEnc\n\nclass CPabe09(ABEnc):\n    \"\"\"\n    >>> from charm.toolbox.pairinggroup import PairingGroup,GT\n    >>> group = PairingGroup('SS512')\n    >>> cpabe = CPabe09(group)\n    >>> msg = group.random(GT)\n    >>> (master_secret_key, master_public_key) = cpabe.setup()\n    >>> policy = '((ONE or THREE) and (TWO or FOUR))'\n    >>> attr_list = ['THREE', 'ONE', 'TWO']\n    >>> secret_key = cpabe.keygen(master_public_key, master_secret_key, attr_list)\n    >>> cipher_text = cpabe.encrypt(master_public_key, msg, policy)\n    >>> decrypted_msg = cpabe.decrypt(master_public_key, secret_key, cipher_text)\n    >>> decrypted_msg == msg\n    True\n    \"\"\"\n    \n    def __init__(self, groupObj):\n        ABEnc.__init__(self)\n        global util, group\n        util = SecretUtil(groupObj, debug)        \n        group = groupObj\n                        \n    def setup(self):\n        g1, g2 = group.random(G1), group.random(G2)\n        alpha, a = group.random(), group.random()        \n        e_gg_alpha = pair(g1,g2) ** alpha\n        msk = {'g1^alpha':g1 ** alpha, 'g2^alpha':g2 ** alpha}        \n        pk = {'g1':g1, 'g2':g2, 'e(gg)^alpha':e_gg_alpha, 'g1^a':g1 ** a, 'g2^a':g2 ** a}\n        return (msk, pk)\n    \n    def keygen(self, pk, msk, attributes):        \n        t = group.random()\n        K = msk['g2^alpha'] * (pk['g2^a'] ** t)\n        L = pk['g2'] ** t\n        k_x = [group.hash(s, G1) ** t for s in attributes]\n        \n        K_x = {}\n        for i in range(0, len(k_x)):\n            K_x[ attributes[i] ] = k_x[i]    \n\n        key = { 'K':K, 'L':L, 'K_x':K_x, 'attributes':attributes }\n        return key\n    \n    def encrypt(self, pk, M, policy_str):\n        # Extract the attributes as a list\n        policy = util.createPolicy(policy_str)        \n        p_list = util.getAttributeList(policy)\n        s = group.random()\n        C_tilde = (pk['e(gg)^alpha'] ** s) * M\n        C_0 = pk['g1'] ** s\n        C, D = {}, {}\n        secret = s\n        shares = util.calculateSharesList(secret, policy)\n\n        # ciphertext\n        for i in range(len(p_list)):\n            r = group.random()\n            if shares[i][0] == p_list[i]:\n               attr = shares[i][0].getAttribute() \n               C[ p_list[i] ] = ((pk['g1^a'] ** shares[i][1]) * (group.hash(attr, G1) ** -r))\n               D[ p_list[i] ] = (pk['g2'] ** r)\n        \n        if debug: print(\"SessionKey: %s\" % C_tilde)\n        return { 'C0':C_0, 'C':C, 'D':D , 'C_tilde':C_tilde, 'policy':policy_str, 'attribute':p_list }\n    \n    def decrypt(self, pk, sk, ct):\n        policy = util.createPolicy(ct['policy'])\n        pruned = util.prune(policy, sk['attributes'])\n        if pruned == False:\n            return False\n        coeffs = util.getCoefficients(policy)\n        numerator = pair(ct['C0'], sk['K'])\n        \n        # create list for attributes in order...\n        k_x, w_i = {}, {}\n        for i in pruned:\n            j = i.getAttributeAndIndex()\n            k = i.getAttribute()\n            k_x[ j ] = sk['K_x'][k]\n            w_i[ j ] = coeffs[j]\n            #print('Attribute %s: coeff=%s, k_x=%s' % (j, w_i[j], k_x[j]))\n            \n        C, D = ct['C'], ct['D']\n        denominator = 1\n        for i in pruned:\n            j = i.getAttributeAndIndex()\n            denominator *= ( pair(C[j] ** w_i[j], sk['L']) * pair(k_x[j] ** w_i[j], D[j]) )   \n        return ct['C_tilde'] / (numerator / denominator)"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"SessionKey: [4897898898501355351683453535780272251374740691648870523298963161176459049718631704623165917580790112782364738858654913088188127564635790942994867351641166, 5594148607004606790445539725307269743280460162251313297488780598171706543996991704109849456242130630540511011310380099671661836103996130031750688538585740]\n"},{"data":{"text/plain":"True"},"execution_count":3,"metadata":{},"output_type":"execute_result"}],"source":"from charm.toolbox.pairinggroup import PairingGroup,GT\ndebug = True\ngroup = PairingGroup('SS512')\ncpabe = CPabe09(group)\nmsg = group.random(GT)\n(master_secret_key, master_public_key) = cpabe.setup()\npolicy = '((ONE or THREE) and (TWO or FOUR))'\nattr_list = ['THREE', 'ONE', 'TWO']\nsecret_key = cpabe.keygen(master_public_key, master_secret_key, attr_list)\ncipher_text = cpabe.encrypt(master_public_key, msg, policy)\ndecrypted_msg = cpabe.decrypt(master_public_key, secret_key, cipher_text)\ndecrypted_msg == msg"}
{"cell_type":"markdown","metadata":{},"source":"## Appendix - CryptoBase"}
{"cell_type":"code","execution_count":7,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"from charm.toolbox.paddingschemes import PKCS7Padding\nfrom charm.toolbox.securerandom import OpenSSLRand\nfrom charm.core.crypto.cryptobase import MODE_CBC,AES,selectPRP\nimport json\nfrom base64 import b64encode,b64decode\n\nclass SymmetricCryptoAbstraction(object):\n    \"\"\"\n    Abstraction for symmetric encryption and decryption of data.\n    Ideally provide an INDCCA2 secure symmetric container for arbitrary data.\n    Currently only supports primitives that JSON can encode and decode.\n  \n    A large number of the schemes can only encrypt group elements \n    and do not provide an efficient mechanism for encoding byte in\n    those elements. As such we don't pick a symmetric key and encrypt \n    it asymmetrically. Rather, we hash a random group element to get the\n    symmetric key.\n    >>> from charm.toolbox.pairinggroup import PairingGroup,GT\n    >>> groupObj = PairingGroup('SS512')\n    >>> from charm.core.math.pairing import hashPair as extractor\n    >>> a = SymmetricCryptoAbstraction(extractor(groupObj.random(GT)))\n    >>> ct = a.encrypt(b\"Friendly Fire Isn't\")\n    >>> a.decrypt(ct)\n    b\"Friendly Fire Isn't\"\n    \"\"\"\n\n    def __init__(self,key, alg = AES, mode = MODE_CBC):\n        self._alg = alg\n        self.key_len = 16\n        self._block_size = 16 \n        self._mode = mode\n        self._key = key[0:self.key_len]\n        self._padding = PKCS7Padding();\n \n    def _initCipher(self,IV = None):\n        if IV == None :\n            IV =  OpenSSLRand().getRandomBytes(self._block_size)\n        self._IV = IV\n        return selectPRP(self._alg,(self._key,self._mode,self._IV))\n\n    def __encode_decode(self,data,func):\n        data['IV'] = func(data['IV'])\n        data['CipherText'] = func(data['CipherText'])\n        return data\n\n    #This code should be factored out into  another class\n    #Because json is only defined over strings, we need to base64 encode the encrypted data\n    # and convert the base 64 byte array into a utf8 string\n    def _encode(self,data):\n        return self.__encode_decode(data,lambda x:b64encode(x).decode('utf-8'))\n\n    def _decode(self,data):\n        return self.__encode_decode(data,lambda x:b64decode(bytes(x,'utf-8')))\n\n    def encrypt(self, message):\n        #This should be removed when all crypto functions deal with bytes\"\n        if type(message) != bytes :\n            message = bytes(message,\"utf-8\")\n        ct = self._encrypt(message)\n        #JSON strings cannot have binary data in them, so we must base64 encode  cipher\n        cte = json.dumps(self._encode(ct))\n        return cte\n\n    def _encrypt(self,message):\n        #Because the IV cannot be set after instantiation, decrypt and encrypt \n        # must operate on their own instances of the cipher \n        cipher = self._initCipher() \n        ct= {'ALG':self._alg,\n            'MODE':self._mode,\n            'IV':self._IV,\n            'CipherText':cipher.encrypt(self._padding.encode(message))\n            }\n        return ct\n\n    def decrypt(self,cipherText):\n        f = json.loads(cipherText)\n        return self._decrypt(self._decode(f)) #.decode(\"utf-8\")\n\n    def _decrypt(self,cipherText):\n        cipher = self._initCipher(cipherText['IV'])\n        msg = cipher.decrypt(cipherText['CipherText'])\n        return self._padding.decode(msg)"}
{"cell_type":"code","execution_count":8,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"b\"Friendly Fire Isn't\""},"execution_count":8,"metadata":{},"output_type":"execute_result"}],"source":"from charm.toolbox.pairinggroup import PairingGroup,GT\ngroupObj = PairingGroup('SS512')\nfrom charm.core.math.pairing import hashPair as extractor\na = SymmetricCryptoAbstraction(extractor(groupObj.random(GT)))\nct = a.encrypt(b\"Friendly Fire Isn't\")\na.decrypt(ct)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}