{"kernelspec":{"display_name":"Python 2 (Ubuntu, plain)","language":"python","name":"python2-ubuntu"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"},"name":"03_ECC.ipynb","widgets":{"state":{"fdb67f6c497b42e7a697c7ea538cf7dd":{"views":[{"cell_index":2}]}},"version":"1.2.0"}}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# ECC\n先推薦一些不錯的教材:[1](http://andrea.corbellini.name/tag/ecc/),[2](https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture14.pdf),[3](https://blog.cloudflare.com/a-relatively-easy-to-understand-primer-on-elliptic-curve-cryptography/),[4](https://jeremykun.com/category/cryptography/page/2/)\n\n跟RSA一樣同樣用 elliptic curves, 通常我們可以做以下兩件事:\n\n- Digital signatures (public key equivalent of message authentication codes) Alice 用 private key 簽署, 然後其他人用 public key 驗證\n- Encryption with elliptic curves: 通常用來作金鑰交換， Alice 用 elliptic curve Diffie-Hellman (ECDH) 來產生跟Bob的 shared key\n\n## Standard Curve\n\n除了[certicom](https://www.certicom.com/)外，IEEE1363和NIST方面有定義出一些建議使用的curve，其中NIST三條標準的 elliptic curve 為:\n\n- NIST P256 curve, which is equivalent to an AES-128 key (also known as secp256r1)\n- NIST P384 curve, which is equivalent to an AES-192 key (also known as secp384r1)\n- NIST P521 curve, which is equivalent to an AES-256 key (also known as secp521r1)\n\n另外還有其他著名的curve像是 Curve25519 curve (key exchange使用), Ed25519 curve (數位簽章使用)，更多curve 選擇[可參考](http://safecurves.cr.yp.to/)\n\n> 最近也有一個有趣的專案[Million Dollar Curve](http://cryptoexperts.github.io/million-dollar-curve/)，想要用樂透等公開random source來建立第三方可驗證的curve\n\nECC的 Key Exchange (ECDH) 紀錄在 in NIST publication [800-56Ar2](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar2.pdf)中"}
{"cell_type":"markdown","metadata":{},"source":"## Mathematics Behind Elliptic Curves\n\nElliptic curve是什麼呢? 事實上著名的Fermat's Last Theorem便是由elliptic curve解開的(不過是定義於實數域的elliptic curve)，可參考[數學女孩](http://www.books.com.tw/products/0010507212)\n\n> [Wolfram MathWorld](http://mathworld.wolfram.com/EllipticCurve.html)有完整數學上的定義\n\n我們可以把他想成由以下方程式組成的點:\n\n$y^2=x^3+ax+b$\n\n其中 $4a^3+27b^2 \\neq 0$ (用來排除 singular curves). 這種形式稱為 Weierstrass normal form for elliptic curves\n\n根據不同的a, b值, elliptic curves 會呈現不同的形狀， 我們在實數上畫出來 elliptic curves 是對稱x軸的!\n\n通常我們會把**無窮遠點**也加入 curve中，我們將它標記為 0\n\n故納入無窮遠點後的橢圓曲線為:\n\n$\\{(x,y)∈R^2 | y^2=x^3+ax+b, 4a^3+27b^2 \\neq 0\\} ∪ \\{0\\}$， 以下我們簡單的畫出elliptic curve和上面的點加法(後面會進一步介紹)給讀者參考:"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::a6428a13-45ce-4892-a40f-102653c07f88","text/plain":"<matplotlib.figure.Figure at 0x7f30c4263150>"},"metadata":{},"output_type":"display_data"},{"data":{"text/plain":"<function __main__.interactive_curve>"},"execution_count":1,"metadata":{},"output_type":"execute_result"}],"source":"import numpy as np\nimport matplotlib.pyplot as plt\nfrom elliptic import *\nfrom fractions import Fraction as frac\nimport numpy.polynomial.polynomial as poly\n\ndef drawLine2P(x,y,xlims):\n    xrange = np.arange(xlims[0],xlims[1],0.1)\n    A = np.vstack([x, np.ones(len(x))]).T\n    k, b = np.linalg.lstsq(A, y)[0]\n    plt.plot(xrange, k*xrange + b, 'k')\n\ndef interactive_curve(a=-4, b=4, Px=3, Qx=-2):\n    if 4*a^3 + 27*b^2 == 0:\n        print 'The choice of a = %s and b = %s does not define an elliptic curve because this makes 27a^3 + 4b^2 = 0.'%(a,b)\n    else:\n        y, x = np.ogrid[-5:5:100j, -5:5:100j]\n        plt.contour(x.ravel(), y.ravel(), pow(y, 2) - pow(x, 3) - x * a - b, [0])\n        C = EllipticCurve(a=frac(a), b=frac(b))\n        ro = poly.polyroots((b,a,0,1))\n        ro = ro[np.isreal(ro)]\n        if(len(ro) == 1):\n            if Px < ro[0].real:\n                Px = ro[0].real\n            if Qx < ro[0].real:\n                Qx = ro[0].real\n        else:\n            if ro[1].real < Px < ro[2].real:\n                Px = ro[1].real\n        P = C.from_x(frac(Px))\n        Q = C.from_x(frac(Qx))\n        R =  P + Q\n        zero = Ideal(C)\n        drawLine2P([float(P[0]),float(Q[0])],[float(P[1]),float(Q[1])],[-5,5])\n        plt.plot(float(P[0]),float(P[1]), 'o')\n        plt.plot(float(Q[0]),float(Q[1]), 'o')\n        plt.plot(float(R[0]),float(R[1]), 'o')\n        plt.xlim([-5,5])\n        plt.ylim([-5,5])\n        plt.annotate(r'$P$',\n             xy=(float(P[0]), float(P[1])), xycoords='data',\n             xytext=(+10, +30), textcoords='offset points', fontsize=16,\n             arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\"))\n        plt.annotate(r'$Q$',\n             xy=(float(Q[0]), float(Q[1])), xycoords='data',\n             xytext=(+10, +30), textcoords='offset points', fontsize=16,\n             arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\"))\n        plt.annotate(r'$R$',\n             xy=(float(R[0]), float(R[1])), xycoords='data',\n             xytext=(+10, +30), textcoords='offset points', fontsize=16,\n             arrowprops=dict(arrowstyle=\"->\", connectionstyle=\"arc3,rad=.2\"))\n\n        plt.grid()\n        plt.show()\n\nfrom IPython.html.widgets import interact\ninteract(interactive_curve, a=[-10, 3], b=[-10,10], Px=[-20,20], Qx=[-20, 20])"}
{"cell_type":"markdown","metadata":{},"source":"### Group\n我們這邊簡單介紹一些abstract algebra中的群論：一個set我們定義 \"addition\" 並標示為 +， 此 set G 稱之為 group, addition 必續根據下列四個性質來定義!\n\n1. Closure: 若$a,b$在$G$內, 則$a+b$也要在 $G$內\n2. Associativity: $(a+b)+c=a+(b+c)$\n3. 有 identity element $0$ 使得 $a+0=0+a=a$\n4. 所有元素有 inverse, 亦即對任意 $a$ 一定找的到 $b$ 使得 $a+b=0$\n\n>若再加上 commutativity: $a+b=b+a$ 則此 group 稱為 abelian group.\n\n我們常見的加法配上 integer numbers 組成的set $Z$ 便是 group (事實上他是 abelian group).然而自然數$N$就不是了，因為不符合第四個條件。\n\n若我們能證明某一set滿足以上性質，我們就可以借用抽象代數中的群的相關特性!! 例如: identity element是唯一的，inverse也是唯一的"}
{"cell_type":"markdown","metadata":{},"source":"### Group Law of Elliptic Curve\n#### Geometric addition\n\n我們可以定義橢圓曲線群如下:\n\n1. Group 中的元素是 elliptic curve上的點\n2. Identity element 是無窮遠點 0;\n3. 橢圓曲線上點 P 的 inverse 是對 x 軸鏡射的點\n\nAddition定義為: 給定三個 aligned 且 non-zero 的點 P, Q, R, P+Q+R=0\n![](http://andrea.corbellini.name/images/three-aligned-points.png)\n\n經由這樣的定義我們可以得知這個點是無順序性不相關的，也就是說假設 P, Q, R 是 aligned, 則 P+(Q+R)=Q+(P+R)=R+(P+Q)=⋯=0. 因此我們的 ``+`` operator 是 associative 且 commutative 故為一個 abelian group! 既然在abelian group我們就可以把 P+Q+R=0 寫成 P+Q=-R 因此得到圖像加法如下:\n![](http://andrea.corbellini.name/images/point-addition.png)\n\n> 可以由[此](https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/reals-add.html)來感受加法!!\n\n#### Algebraic addition\n接下來我們把上述加法寫成數學式，考慮兩個點$P=(x_P,y_P), Q=(x_Q,y_Q)$，假設兩者不同，通過兩點的線斜率為\n\n$m = \\frac{y_P - y_Q}{x_P - x_Q}$\n\n而他與橢圓曲線的交點為$R = (x_R, y_R)$\n\n$\\begin{array}{rcl}\n    x_R & = & m^2 - x_P - x_Q \\\\\n    y_R & = & y_P + m(x_R - x_P)\n\\end{array}$\n\n因此$(x_P, y_P) + (x_Q, y_Q) = (x_R, -y_R)$\n\n> 若$P=Q$的話，經由微分$y_P = \\pm \\sqrt{x_P^3 + ax_P + b}$ 可得 $m = \\frac{3 x_P^2 + a}{2 y_P}$\n\n### Scalar Multiplication\n連加$n$次$P$可寫成$nP$此運算稱為scalar multiplication。\n> [這邊](https://cdn.rawgit.com/andreacorbellini/ecc/920b29a/interactive/reals-mul.html)可感受乘法\n\n在實際時做上，我們可以藉由double-and-add來加速此運算"}
{"cell_type":"markdown","metadata":{},"source":"```\ndef bits(n):\n    \"\"\"\n    Generates the binary digits of n, starting\n    from the least significant bit.\n\n    bits(151) -> 1, 1, 1, 0, 1, 0, 0, 1\n    \"\"\"\n    while n:\n        yield n & 1\n        n >>= 1\n\ndef double_and_add(n, x):\n    \"\"\"\n    Returns the result of n * x, computed using\n    the double and add algorithm.\n    \"\"\"\n    result = 0\n    addend = x\n\n    for bit in bits(n):\n        if bit == 1:\n            result += addend\n        addend *= 2\n\n    return result\n```"}
{"cell_type":"markdown","metadata":{},"source":"### Logarithm\n橢圓曲線基於的數學問題是elliptic curve discret logarithm problem(ECDLP): 給定$n, P$我們可以很快利用上述方法算出$Q=nP$，然而給$Q$和$P$要推$n$就不容易了...。\n\n### Finite Field\n實數域的elliptic curve並不能拿來密碼學使用(前述是在實數中)，這邊我們介紹Galois Field (Finite Field)。 Finite field 是一個元素為有限數目的set， 一個簡單的例子是 integers modulo p ($p$為質數)。 我們通常寫成 $Z/p, GF(p), F_p$. \n\n在 field 中我們有兩種 binary operations: addition (+) 和 multiplication (·)， 兩者皆為 closed, associative 且 commutative。對此兩種運算, 都存在著唯一的identity element， 且對field內的 element 都有唯一的 inverse element。 最後 multiplicationy在field中是 distributive over addition: $x⋅(y+z)=x⋅y+x⋅z$\n\n> $x/y$在field中可寫成$x*y^{-1}$，"}
{"cell_type":"markdown","metadata":{},"source":"## EC over Finite Field\n接下來我們將elliptic curve限制在 Finit Field中 (注意其仍為abelian group!)\n\n$\n\\begin{array}{rcl}\n  \\left\\{(x, y) \\in (\\mathbb{F}_p)^2 \\right. & \\left. | \\right. & \\left. y^2 \\equiv x^3 + ax + b \\pmod{p}, \\right. \\\\\n  & & \\left. 4a^3 + 27b^2 \\not\\equiv 0 \\pmod{p}\\right\\}\\ \\cup\\ \\left\\{0\\right\\}\n\\end{array}\n$\n\n0 為無窮遠點, 且 a 和 b 為兩個 $F_p$中的 integer.\n\n來感受一下現在他長怎麼樣吧( $y^2 \\equiv x^3 - 7x + 10 \\pmod{p}$ 當 $p=19,97,127,487$ 對每一x最多會有兩點y。 另外點是對 $y=p/2$ 對稱的!)\n\n![](http://andrea.corbellini.name/images/elliptic-curves-mod-p.png)\n\n經過此一限制之後，geometric addition會變得不太一樣(可以玩前述tool)，不過我們保持定義的話，algebra addition仍然可保持相同公式(多了modulus P)。\n\n接下來我們可以證明出 multiples of P 實際上是一個 ``cyclic subgroup of the group formed by the elliptic curve``，藉此我們進一步定義出elliptic curve的order(所有點的數目)和點的order(加幾次可以回到自己)。"}
{"cell_type":"markdown","metadata":{},"source":"## Elliptic Curve for Cryptography\n對密碼學應用來說，我們會去選擇高order的 subgroups。 實務上我們會先選 elliptic curve, 然後計算 order (N), 選擇 high divisor的(n) 來當 subgroup order， 最後找到適合的 base point。\n\nLagrange's theorem 告訴我們 $h=N/n$ 永遠是整數 (因為 $n$ 為 $N$的 divisor). $h$ 稱作 cofactor of the subgroup.\n\n假設 $E$ 為定義在 field $K$ 上的 elliptic curve，根據 group addition law 我們可以知道每一個$E$上的點都可以產生出一個 cyclic group $G$。若這個 $G$ 的 order 是質數的話就可以用在cryptography上。\n\n> 這表示group operation, inversion, hasing都可以很快完成，但是DLP很難解\n\n因此跟$F^*$乘法群的對照便是**我們可以用$E(K)$上的點配上點加法來類比乘法群元素**。在乘法群中，我們會選擇一個$F^*$的subgroup $G$ order為$n$，但任意選通常不會有此order，因此常見的做法是用演算法隨機hash到一個 $x \\in F^*$，然後再把他exponential 成 $N/n$，($N$為 $F^*$的元素數量)。\n\n橢圓曲線也是如此，假設$N = \\#E(K)$，\n\n  - 選一個curve $E(K)$，計算他的 order N\n  - 選一個prime $n$整除$N$，但是$n^2$不能整除$N$， 來建立出 order 為 $n$的 subgroup。並計算 cofactor $h=N/n$\n  - 選擇隨機點 $P$，然後計算 $G=hP$ (hashing也是如此做)\n  - 接下來group operation用addition，negate去反轉$y$做標，點乘法用point multiplication。\n\n若 $G$ 為 $O$, 回到 step 3. 最後我們得到 subgroup with order $n$ 和 cofactor $h$.\n\n\n### Domain Parameter\nElliptic curve algorithms 是定義於 **cyclic subgroup of an elliptic curve over a finite field** 因此我們會有下列參數:\n\n- The prime $p$ that specifies the size of the finite field.\n- The coefficients $a$ and $b$ of the elliptic curve equation.\n- The base point $G$ that generates our subgroup.\n- The order $n$ of the subgrouop.\n- The cofactor $h$ of the subgroup.\n\n也就是 domain parameters包含tuple $(p,a,b,G,n,h)$\n\n事實上有些curve是不安全的，我們如何確保選出的curve是安全的呢，有一種常見作法如下\n![](http://andrea.corbellini.name/images/random-parameters-generation.png)\n\n> Curve 用此方法產生稱作 verifiably random. 這個用 hashes 產生 parameters 的方法叫 \"nothing up my sleeve\", 常常被用於 cryptography中\n\n他給我們一些信心，curve不會是 crafted 而有特定 vulnerabilities 只有設計者知道。 事實上設計者給我們seed和curve， 他沒辦法控制我們選取 parameters $a$ 和 $b$， 因此比較有安全感。\n\n> 標準產生和驗證 random curves 的方法訂於 ANSI X9.62 並用到 SHA-1. 可以看[SECG](http://www.secg.org/sec1-v2.pdf)的相關說明\n\n可以用以下程式來確認:"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"%%bash\npython3 verifyrandom.py"}
{"cell_type":"markdown","metadata":{},"source":"## ECC\n\n- Private key 為在$\\{1,…,n−1\\}$之間的 random integer $d$ ($n$ 為 subgroup 的order).\n- Public key 為 $H=dG$ 這個point ($G$ 為 subgroup的base point).\n\n接下來我們將重點放在 ECDH (Elliptic curve Diffie-Hellman)(用於加密), 和 ECDSA (Elliptic Curve Digital Signature Algorithm)(用於簽章)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"%%bash\npython3 ecdhe.py"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"%%bash\npython3 ecdsa.py"}
{"cell_type":"markdown","metadata":{},"source":"> 最後，我們上述都是在prime filed, affine coordinate, Weierstrass form curve，更多的其他選擇和加法公式可參考 [EFD](https://hyperelliptic.org/EFD/)"}
{"cell_type":"markdown","metadata":{},"source":"## Pyelliptic\n在這邊我們先使用 PyElliptic 這個提供 ECC class 的library，來實際應用在金鑰交換以及數位簽章上\n\n### Generating Keys\n\n假設我們AES用256 bit, 所以這邊至少要用到 P521的curve"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"import pyelliptic\ndef generate_key():\n     return pyelliptic.ECC(curve='secp521r1')"}
{"cell_type":"markdown","metadata":{},"source":"Public 和 private keys 可以從curve exported 出來"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"secp521r1\n015a128578899572cfa87c6ac06775dee5a65162a20ae6f172bca5392c0041f602949e140fc2549064d2cc72877118490d68579adbc5b7fa158fa9ea7883f522cac8 132 66\n04009c084f51e7599738bc8525bc877cf0350573ca8ac6f6685ecd14182ffbb946a3d25baeeef61837710255e11105bc4470de84a29dc5505c88da3f4364d49776e08b004902edabfe1c39356eb795f42f527bf01644d06fa6e1498ba45e09d68afe4227430fa2a6b1eccbd1a5f6fed3e8f3a841dcb53e6e1dcb48b4bb8f3a4b2e6fd438c6 266 133\n"}],"source":"curve = generate_key()\npriv = curve.get_privkey()\npub = curve.get_pubkey()\nprint curve.get_curve()\nprint priv.encode('hex'), len(priv.encode('hex')), len(priv)\nprint pub.encode('hex'), len(pub.encode('hex')), len(pub)"}
{"cell_type":"markdown","metadata":{},"source":"### Signing Messages\n\n通常做數位簽章的時候， 我們會先計算 message 的 hash 再做簽章。 PyElliptic 會使用 SHA-512 來做 ECDSA."}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def sign(key, msg):\n    \"\"\"Sign a message with the ECDSA key.\"\"\"\n    return key.sign(msg)"}
{"cell_type":"markdown","metadata":{},"source":"驗證時候的input是 serialised public key 然後匯入 pyelliptic.ecc.ECC instance 做運算"}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def verify(pub, msg, sig):\n    \"\"\"Verify the signature on a message.\"\"\"\n    return pyelliptic.ECC(curve='secp521r1', pubkey=pub).verify(sig, msg)"}
{"cell_type":"markdown","metadata":{},"source":"### Encryption\n\n現在來說明如何用ECDH來產生shared key"}
{"cell_type":"markdown","metadata":{},"source":"用 pyelliptic時， private key 要是 instance of pyelliptic.ecc.ECC; 而 public key 要是 serialised form."}
{"cell_type":"code","execution_count":6,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"32"},"execution_count":6,"metadata":{},"output_type":"execute_result"}],"source":"shared_key = curve.get_ecdh_key(pub)\nlen(shared_key)"}
{"cell_type":"code","execution_count":7,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def shared_key(curve, pub):\n    \"\"\"Generate a new shared encryption key from a keypair.\"\"\"\n    shared_key = curve.get_ecdh_key(pub)\n    return shared_key"}
{"cell_type":"markdown","metadata":{},"source":"### Ephemeral keys\n\n接下來我們來看看常見的 hybrid encryption的方式，我們會用 ephemeral keys 來做 encryption;也就是我們每次加密會產生 elliptic curve key pair 這種加密方法叫 elliptic curve integrated encryption scheme,  ECIES。 (或更準確來說，因為 key exchange 為 on the fly 完成，故稱為 ECDHE)"}
{"cell_type":"code","execution_count":8,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"import struct\nimport Crypto.Random.OSRNG.posix as RNG\nimport Crypto.Cipher.AES as AES \n__AES_KEYLEN = 32\n\ndef generate_nonce():\n    \"\"\"Generate a random number used once.\"\"\"\n    return RNG.new().read(AES.block_size)\n\ndef pad_data(data):\n    \"\"\"pad_data pads out the data to an AES block length.\"\"\"\n    # return data if no padding is required\n    if len(data) % 16 == 0:\n        return data\n\n    # subtract one byte that should be the 0x80\n    # if 0 bytes of padding are required, it means only\n    # a single \\x80 is required.\n\n    padding_required = 15 - (len(data) % 16)\n\n    data = '%s\\x80' % data\n    data = '%s%s' % (data, '\\x00' * padding_required)\n\n    return data\n\ndef unpad_data(data):\n    \"\"\"unpad_data removes padding from the data.\"\"\"\n    if not data:\n        return data\n\n    data = data.rstrip('\\x00')\n    if data[-1] == '\\x80':\n        return data[:-1]\n    else:\n        return data\n\ndef sym_encrypt(data, key):\n     \"\"\"\n     Encrypt data using AES in CBC mode. The IV is prepended to the\n     ciphertext.\n     \"\"\"\n     data = pad_data(data)\n     ivec = generate_nonce()\n     aes = AES.new(key, AES.MODE_CBC, ivec)\n     ctxt = aes.encrypt(data)\n     return ivec + ctxt\n \n \ndef sym_decrypt(ciphertext, key):\n     \"\"\"\n     Decrypt a ciphertext encrypted with AES in CBC mode; assumes the IV\n     has been prepended to the ciphertext.\n     \"\"\"\n     if len(ciphertext) <= AES.block_size:\n         raise Exception(\"Invalid ciphertext.\")\n     ivec = ciphertext[:AES.block_size]\n     ciphertext = ciphertext[AES.block_size:]\n     aes = AES.new(key, AES.MODE_CBC, ivec)\n     data = aes.decrypt(ciphertext)\n     return unpad_data(data)\n\n\ndef encrypt(pub, msg):\n    \"\"\"\n    Encrypt the message to the public key using ECIES. The public key\n    should be a serialised public key.\n    \"\"\"\n    ephemeral = generate_key() # Alice's private key\n    key = shared_key(ephemeral, pub) #Symmetric key derives from ECDH (alice_priv + bob_pub)\n    ephemeral_pub = struct.pack('>H', len(ephemeral.get_pubkey()))\n    print ephemeral_pub, len(ephemeral.get_pubkey())\n    ephemeral_pub += ephemeral.get_pubkey() # Alice's public key\n    print ephemeral_pub\n    return ephemeral_pub + sym_encrypt(msg, key)\n\ndef decrypt(priv, msg):\n    \"\"\"\n    Decrypt an ECIES-encrypted message with the private key.\n    \"\"\"\n    ephemeral_len = struct.unpack('>H', msg[:2])[0]\n    ephemeral_pub = msg[2:2+ephemeral_len] # Alice's public key\n    key = shared_key(priv, ephemeral_pub) #symmetric key derives from ECDH(bob_priv, alice_pub)\n    return sym_decrypt(msg[2+ephemeral_len:], key)"}
{"cell_type":"markdown","metadata":{},"source":"上述我們將 public key 加到開頭， 包含 public key 的長度，然後將 ciphertext 接在後面。 解密時需要解回 public key (先讀取 length 然後從  message 中擷取出 public key) 接著用ECDH 找出 shared key後進行訊息加密"}
{"cell_type":"code","execution_count":9,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"\u0000� 133\n\u0000�\u0004\u0001�Ɠ\u0000�>\u001d�f'�@iA��\u0019�\u0006VD��VHs�}�\u0018\u0018օ�ع{xI�v��t���8p�3_��z�ͩ�U�}�,\u0001�$��\t�1�\u001c4��&�@jY\u0016?�V��V�\u0014�.\u0005h�Y\u0002I�0�\u001f�Ê4�+�\u0006/�w[@\u0007-ٕI� �g�\nAG is god\n"}],"source":"curve = generate_key() # Bob generate private key\npub  = curve.get_pubkey() # Alice get the pubkey from Bob\nplaintext = 'AG is god'\nciphertext = encrypt(pub, plaintext) # Alice encrypt message\nprint decrypt(curve, ciphertext) #Bob decrypt it"}
{"cell_type":"markdown","metadata":{},"source":"### Key Exchange\n\n那麼 Alice 要如何得知public key是真的屬於Bob的呢? 認證方法有兩種: centralised and decentralised. \n\nTLS/SSL用的是 centralised 的方法: root certificate1 authority (CA) 簽署 intermediary CA 的 key, 然後intermediate CA 再簽署 user keys. 例如 Bob 產生 SSL keypair. 然後接著產生 certificate signing request (CSR) 並送給 CA 要求認證. CA根據不同等級進行收費和認證，最後進行簽署. Bob 將簽署好的 SSL certificate放上webserver， Alice 若相信簽署的CA就會用Bob的 public key，通常 Alice 的 web browser 會有 計載了部分 CA 的 public keys (像是 VeriSigns) 並幫她驗證各個網站的憑證. 這套系統就是 public key infrastructure (PKI)\n\n另一個做法是 PGP 用 decentralised model. 在 PGP 中有一個 Web of Trust (信任網). 例如當 Carol 要傳訊息給 Bob 並把她的 public key給Bob， Bob 會去確認 Carol的 key 是否經過其他人簽署. 例如若　Bob 知道Alice的public key屬於 Alice 且相信她， 而 Alice 曾簽署 Carol’s key. Bob 在其憑證上看到 Alice的 signature 則他對 Carol的信任度就會提高. 接著假設 Dave 的 key 有被 Carol 簽署過, Bob 會對 Dave多一些信心, 但可能沒那麼高，因為他未必相信Carol是合法的簽署者. 基由以上機制，Bob會有 **various trust levels**, 進而形成 web of trust \n\n接下來看一個完整的例子"}
{"cell_type":"code","execution_count":10,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Hello Bob\nTrue\nFor ECDH key agreement, the keys must be defined on the same curve !\n0215667cc3ed08b482889e248dc521de9acf99bc4e5db4bc1bc6ed2af3a3f192\n0215667cc3ed08b482889e248dc521de9acf99bc4e5db4bc1bc6ed2af3a3f192\n"}],"source":"import binascii\n# Asymmetric encryption\nalice = pyelliptic.ECC() # default curve: sect283r1\nbob = pyelliptic.ECC(curve='sect571r1')\n\nciphertext = alice.encrypt(\"Hello Bob\", bob.get_pubkey(),\n                           ephemcurve='sect571r1')\nprint(bob.decrypt(ciphertext))\n\nsignature = bob.sign(\"Hello Alice\")\n# alice's job :\nprint(pyelliptic.ECC(pubkey=bob.get_pubkey(),\n                     curve='sect571r1').verify(signature, \"Hello Alice\"))\n\n# ERROR !!!\ntry:\n    key = alice.get_ecdh_key(bob.get_pubkey())\nexcept:\n    print(\"For ECDH key agreement, the keys must be defined on the same curve !\")\n\nalice = pyelliptic.ECC(curve='sect571r1')\nprint(binascii.hexlify(alice.get_ecdh_key(bob.get_pubkey())))\nprint(binascii.hexlify(bob.get_ecdh_key(alice.get_pubkey())))"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"## Cryptography"}
{"cell_type":"markdown","metadata":{},"source":"我們進一步貼近實務，通常key會經過key derivation function，上述的ECDHE 會比 ECDH更好，因為它提供了 forward secrecy\n\n> 記得對於每次 exchange() 我們需要有對應的  generate_private_key() (ECDHE key exchange)"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"1.4\n"}],"source":"import cryptography\nprint (cryptography.__version__)"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"b'\\x89\\x1ej\\x85\\xd2\\\\\\x98\\xdf\\x0b\\xf6:CQ\\xc0\\xfc\\xdf\\x05\\xc9\\xeb\\xfc1\\xe0\\xfd/\\xf3\\xd1j#\\xf3G\\xcb\\xf4;\\xe1\\xa6%Rb\\x9a\\xf0\\x02-1\\xaed\\xc7G\\xdb' 48\n"}],"source":"from cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\nmessage = b\"encrypted data\"\nprivate_key = ec.generate_private_key(\n    ec.SECP384R1(), default_backend()\n) # Alice private key\npeer_public_key = ec.generate_private_key(\n    ec.SECP384R1(), default_backend()\n).public_key() # Bob's private key and public key\nshared_key = private_key.exchange(ec.ECDH(), peer_public_key)\nprint (shared_key, len(shared_key))"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"簽章看看吧，我們依照[FIPS 186-4](http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf) 來簽\n\n``decode_dss_signature()`` 可以解回DER形式儲存的 signature\n\n> 複習一下，PEM 為 encapsulation format,他可以是數種不同的 key types. 另外 PEM keys 是可讀的會有以下形式: -----BEGIN {format}----- ....-----END {format}-----.\n\n> 另一方面，DER 是 ASN.1 encoding type.他不是encapsulation且 data 是 binary"}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"b'0f\\x021\\x00\\xc8\\xd0Z\\xf4\\xb7?\\x17>s1Y\\xfdh\\xe8\\xac\\x837e\\xe4\\xab\\xf8\\xa4\\xa1h\\xb6\\xd4,\\x8b\\xc8\\x9a\\x10y8\\x1b\\x8e\\xb9q\\x1fi\\xdc\\xc6\\x1dC\\xca\\xfa\\xa6\\xd1\\x1e\\x021\\x00\\xe8\\xb9\\xb0O\\xf5#\\x07\\xb8p\\xed\\xa1\\x90:\\x1b\\xc9\\x13\\x05\\x1c\\x0fw\\xcb8\\xbc\\x86u\\x0f\\n\\x15\\r@\\xf5\\xcf\\x10\\x1d{[(HuO\\xfe\\xa5\\x1c2\\xd2W\\xca\\x97' (30908086150234631117714898008013435892933407549242921165484949594217951499229372249293784529147903169918884546793758, 35819709169227499427924560879277223896697649225502381654726972326434374105261116333677247359836034440264168412531351)\n"},{"data":{"text/plain":"True"},"execution_count":5,"metadata":{},"output_type":"execute_result"}],"source":"from cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature\n\nprivate_key = ec.generate_private_key(\n    ec.SECP384R1(), default_backend()\n) # Alice private key\npublic_key = private_key.public_key() # Alice public key\nsigner = private_key.signer(ec.ECDSA(hashes.SHA256())) # Specify signing alog. and hash function\nmessage = b\"this is some data I'd like to sign\"\nsigner.update(message)\nsignature = signer.finalize()\nprint (signature, decode_dss_signature(signature))\nverifier = public_key.verifier(signature,ec.ECDSA(hashes.SHA256()))\nverifier.update(message)\nverifier.verify()"}
{"cell_type":"markdown","metadata":{},"source":"## OpenSSL"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"  secp112r1 : SECG/WTLS curve over a 112 bit prime field\n  secp112r2 : SECG curve over a 112 bit prime field\n  secp128r1 : SECG curve over a 128 bit prime field\n  secp128r2 : SECG curve over a 128 bit prime field\n  secp160k1 : SECG curve over a 160 bit prime field\n  secp160r1 : SECG curve over a 160 bit prime field\n  secp160r2 : SECG/WTLS curve over a 160 bit prime field\n  secp192k1 : SECG curve over a 192 bit prime field\n  secp224k1 : SECG curve over a 224 bit prime field\n  secp224r1 : NIST/SECG curve over a 224 bit prime field\n  secp256k1 : SECG curve over a 256 bit prime field\n  secp384r1 : NIST/SECG curve over a 384 bit prime field\n  secp521r1 : NIST/SECG curve over a 521 bit prime field\n  prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field\n  prime192v2: X9.62 curve over a 192 bit prime field\n  prime192v3: X9.62 curve over a 192 bit prime field\n  prime239v1: X9.62 curve over a 239 bit prime field\n  prime239v2: X9.62 curve over a 239 bit prime field\n  prime239v3: X9.62 curve over a 239 bit prime field\n  prime256v1: X9.62/SECG curve over a 256 bit prime field\n  sect113r1 : SECG curve over a 113 bit binary field\n  sect113r2 : SECG curve over a 113 bit binary field\n  sect131r1 : SECG/WTLS curve over a 131 bit binary field\n  sect131r2 : SECG curve over a 131 bit binary field\n  sect163k1 : NIST/SECG/WTLS curve over a 163 bit binary field\n  sect163r1 : SECG curve over a 163 bit binary field\n  sect163r2 : NIST/SECG curve over a 163 bit binary field\n  sect193r1 : SECG curve over a 193 bit binary field\n  sect193r2 : SECG curve over a 193 bit binary field\n  sect233k1 : NIST/SECG/WTLS curve over a 233 bit binary field\n  sect233r1 : NIST/SECG/WTLS curve over a 233 bit binary field\n  sect239k1 : SECG curve over a 239 bit binary field\n  sect283k1 : NIST/SECG curve over a 283 bit binary field\n  sect283r1 : NIST/SECG curve over a 283 bit binary field\n  sect409k1 : NIST/SECG curve over a 409 bit binary field\n  sect409r1 : NIST/SECG curve over a 409 bit binary field\n  sect571k1 : NIST/SECG curve over a 571 bit binary field\n  sect571r1 : NIST/SECG curve over a 571 bit binary field\n  c2pnb163v1: X9.62 curve over a 163 bit binary field\n  c2pnb163v2: X9.62 curve over a 163 bit binary field\n  c2pnb163v3: X9.62 curve over a 163 bit binary field\n  c2pnb176v1: X9.62 curve over a 176 bit binary field\n  c2tnb191v1: X9.62 curve over a 191 bit binary field\n  c2tnb191v2: X9.62 curve over a 191 bit binary field\n  c2tnb191v3: X9.62 curve over a 191 bit binary field\n  c2pnb208w1: X9.62 curve over a 208 bit binary field\n  c2tnb239v1: X9.62 curve over a 239 bit binary field\n  c2tnb239v2: X9.62 curve over a 239 bit binary field\n  c2tnb239v3: X9.62 curve over a 239 bit binary field\n  c2pnb272w1: X9.62 curve over a 272 bit binary field\n  c2pnb304w1: X9.62 curve over a 304 bit binary field\n  c2tnb359v1: X9.62 curve over a 359 bit binary field\n  c2pnb368w1: X9.62 curve over a 368 bit binary field\n  c2tnb431r1: X9.62 curve over a 431 bit binary field\n  wap-wsg-idm-ecid-wtls1: WTLS curve over a 113 bit binary field\n  wap-wsg-idm-ecid-wtls3: NIST/SECG/WTLS curve over a 163 bit binary field\n  wap-wsg-idm-ecid-wtls4: SECG curve over a 113 bit binary field\n  wap-wsg-idm-ecid-wtls5: X9.62 curve over a 163 bit binary field\n  wap-wsg-idm-ecid-wtls6: SECG/WTLS curve over a 112 bit prime field\n  wap-wsg-idm-ecid-wtls7: SECG/WTLS curve over a 160 bit prime field\n  wap-wsg-idm-ecid-wtls8: WTLS curve over a 112 bit prime field\n  wap-wsg-idm-ecid-wtls9: WTLS curve over a 160 bit prime field\n  wap-wsg-idm-ecid-wtls10: NIST/SECG/WTLS curve over a 233 bit binary field\n  wap-wsg-idm-ecid-wtls11: NIST/SECG/WTLS curve over a 233 bit binary field\n  wap-wsg-idm-ecid-wtls12: WTLS curvs over a 224 bit prime field\n  Oakley-EC2N-3: \n\tIPSec/IKE/Oakley curve #3 over a 155 bit binary field.\n\tNot suitable for ECDSA.\n\tQuestionable extension field!\n  Oakley-EC2N-4: \n\tIPSec/IKE/Oakley curve #4 over a 185 bit binary field.\n\tNot suitable for ECDSA.\n\tQuestionable extension field!\n  brainpoolP160r1: RFC 5639 curve over a 160 bit prime field\n  brainpoolP160t1: RFC 5639 curve over a 160 bit prime field\n  brainpoolP192r1: RFC 5639 curve over a 192 bit prime field\n  brainpoolP192t1: RFC 5639 curve over a 192 bit prime field\n  brainpoolP224r1: RFC 5639 curve over a 224 bit prime field\n  brainpoolP224t1: RFC 5639 curve over a 224 bit prime field\n  brainpoolP256r1: RFC 5639 curve over a 256 bit prime field\n  brainpoolP256t1: RFC 5639 curve over a 256 bit prime field\n  brainpoolP320r1: RFC 5639 curve over a 320 bit prime field\n  brainpoolP320t1: RFC 5639 curve over a 320 bit prime field\n  brainpoolP384r1: RFC 5639 curve over a 384 bit prime field\n  brainpoolP384t1: RFC 5639 curve over a 384 bit prime field\n  brainpoolP512r1: RFC 5639 curve over a 512 bit prime field\n  brainpoolP512t1: RFC 5639 curve over a 512 bit prime field\n"}],"source":"%%bash\nopenssl ecparam -list_curves"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Field Type: prime-field\nPrime:\n    00:db:7c:2a:bf:62:e3:5e:66:80:76:be:ad:20:8b\nA:   \n    00:db:7c:2a:bf:62:e3:5e:66:80:76:be:ad:20:88\nB:   \n    65:9e:f8:ba:04:39:16:ee:de:89:11:70:2b:22\nGenerator (uncompressed):\n    04:09:48:72:39:99:5a:5e:e7:6b:55:f9:c2:f0:98:\n    a8:9c:e5:af:87:24:c0:a2:3e:0e:0f:f7:75:00\nOrder: \n    00:db:7c:2a:bf:62:e3:5e:76:28:df:ac:65:61:c5\nCofactor:  1 (0x1)\n"}],"source":"%%bash\nopenssl ecparam -param_enc explicit -conv_form uncompressed -text -noout -no_seed -name secp112r1"}
{"cell_type":"markdown","metadata":{},"source":"> 6-4 sony ps3的 attack"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"## Discrte Logarithm Problem\n給定橢圓曲線上兩點 $P$ 和 $Q$ 試著找出滿足 $Q=xP$ 的整數$x$。 記得這些點為 elliptic curve的一個subgroup， base point 為 $G$，而$G$的order 為 $n$。"}
{"cell_type":"markdown","metadata":{},"source":"### Baby-step, giant-step\n我們可以把一個整數 $x$ 寫成 $x=am+b$，其中 $a, m, b$ 皆為任意的整數。 例如我們可以把 $10$ 寫成 $2⋅3+4$\n\n同理我們可以把 discrete logarithm problem 寫成：\n\n$\nQ=xP\n$\n\n$\nQ=(am+b)P\n$\n\n$\nQ=amP+bP\n$\n\n$\nQ−amP=bP\n$\n\nBaby-step giant-step 的想法是 \"meet in the middle\"。 和 brute-force attack 不一樣的地方是，攻擊者先計算 \"一些\" $bP$ 的數值和 \"一些\" $Q−amP$ 的數值直到它們相等，如下所示:\n\n1.計算 $m=\\lceil\\sqrt n\\rceil $\n\n2.對於每一個在 $0,...,m$ 的 $b$ 計算 $bP$ 然後將它存入 hash table。\n\n3.對於每一個在 $0,...,m$ 的 $a$\n\n    1. 計算$amP$\n    \n    1. 計算 $Q−amP$\n    \n    1. 尋找 hash table 中是否存在一個點 $bP$ 使得 $Q−amP=bP$\n    \n    1. 若存在我們回傳 $x=am+b$"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}