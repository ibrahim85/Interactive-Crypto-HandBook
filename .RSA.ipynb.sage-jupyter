{"kernelspec":{"display_name":"Python 2 (SageMath)","language":"python","name":"python2"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{},"source":"Cryptography\n======\n\nRecall the basic setup of cryptography. We have two people, Anabel and Bartolo. Anabel wants to send Bartolo a secure message. What do we mean by \"secure?\" We mean that even though that dastardly Eve might intercept and read the transmitted message, Eve won't learn anything about the actual message Anabel wants to send to Bartolo.\n\nBefore the 1970s, the only way for Anabel to send Bartolo a secure message required Anabel and Bartolo to get together beforehand and agree on a secret method of communicating. To communicate, Anabel first decides on a **message.** The original message is sometimes called the **plaintext.** She then **encrypts** the message, producing a **ciphertext.**\n\nShe then sends the ciphertext. If Eve gets hold of hte ciphertext, she shouldn't be able to decode it (unless it's a poor encryption scheme).\n\nWhen Bartolo receives the ciphertext, he can **decrypt** it to recover the plaintext message, since he agreed on the encryption scheme beforehand."}
{"cell_type":"markdown","metadata":{},"source":"Caesar Shift\n--------------\n\nThe first known instance of cryptography came from Julius Caesar. It was not a very good method. To encrypt a message, he shifted each letter over by 2, so for instance \"A\" becomes \"C\", and \"B\" becomes \"D\", and so on.\n\nLet's see what sort of message comes out.\n"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"alpha = \"abcdefghijklmnopqrstuvwxyz\".upper()\npunct = \",.?:;'\\n \""}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"from functools import partial\n\ndef shift(l, s=2):\n    l = l.upper()\n    return alpha[(alpha.index(l) + s) % 26]\n\ndef caesar_shift_encrypt(m, s=2):\n    m = m.upper()\n    c = \"\".join(map(partial(shift, s=s), m))\n    return c\n\ndef caesar_shift_decrypt(c, s=-2):\n    c = c.upper()\n    m = \"\".join(map(partial(shift, s=s), c))\n    return m"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Original Message: HI\nCiphertext: JK\n"}],"source":"print \"Original Message: HI\"\nprint \"Ciphertext:\", caesar_shift_encrypt(\"hi\")"}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Original Message:\nTobeornottobethatisthequestionWhethertisNoblerinthemindtosufferTheSlingsandArrowsofoutrageousFortuneOrtotakeArmsagainstaSeaoftroublesAndbyopposingendthem\n\nCiphertext:\nVQDGQTPQVVQDGVJCVKUVJGSWGUVKQPYJGVJGTVKUPQDNGTKPVJGOKPFVQUWHHGTVJGUNKPIUCPFCTTQYUQHQWVTCIGQWUHQTVWPGQTVQVCMGCTOUCICKPUVCUGCQHVTQWDNGUCPFDAQRRQUKPIGPFVJGO\n"}],"source":"m = \"\"\"To be, or not to be, that is the question:\nWhether 'tis Nobler in the mind to suffer\nThe Slings and Arrows of outrageous Fortune,\nOr to take Arms against a Sea of troubles,\nAnd by opposing end them.\"\"\"\n\nm = \"\".join([l for l in m if not l in punct])\n\nprint \"Original Message:\"\nprint m\n\nprint\nprint \"Ciphertext:\"\ntobe_ciphertext = caesar_shift_encrypt(m)\nprint tobe_ciphertext"}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Decrypted first message: HI\n"}],"source":"print \"Decrypted first message:\", caesar_shift_decrypt(\"JK\")"}
{"cell_type":"code","execution_count":6,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Decrypted second message:\nTOBEORNOTTOBETHATISTHEQUESTIONWHETHERTISNOBLERINTHEMINDTOSUFFERTHESLINGSANDARROWSOFOUTRAGEOUSFORTUNEORTOTAKEARMSAGAINSTASEAOFTROUBLESANDBYOPPOSINGENDTHEM\n"}],"source":"print \"Decrypted second message:\"\nprint caesar_shift_decrypt(tobe_ciphertext)"}
{"cell_type":"markdown","metadata":{},"source":"Is this a good encryption scheme? No, not really. There are only 26 different things to try. This can be decrypted very quickly and easily, even if entirely by hand.\n\nSubstitution Cipher\n----------------------\n\nA slightly different scheme is to choose a different letter for each letter. For instance, maybe \"A\" actually means \"G\" while \"B\" actually means \"E\". We call this a **substitution cipher** as each letter is substituted for another."}
{"cell_type":"code","execution_count":7,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"import random\npermutation = list(alpha)\nrandom.shuffle(permutation)"}
{"cell_type":"code","execution_count":8,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"ABCDEFGHIJKLMNOPQRSTUVWXYZ\nEMJSLZKAYDGTWCHBXORVPNUQIF\n"}],"source":"# Display the new alphabet\nprint alpha\nsubs = \"\".join(permutation)\nprint subs"}
{"cell_type":"code","execution_count":9,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"def subs_cipher_encrypt(m):\n    m = \"\".join([l.upper() for l in m if not l in punct])\n    return \"\".join([subs[alpha.find(l)] for l in m])\n\ndef subs_cipher_decrypt(c):\n    c = \"\".join([l.upper() for l in c if not l in punct])\n    return \"\".join([alpha[subs.find(l)] for l in c])"}
{"cell_type":"code","execution_count":10,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Original message: this is a test\n\nEncrypted Message: VAYRYREVLRV\n\nDecrypted Message: THISISATEST\n"}],"source":"m1 = \"this is a test\"\n\nprint \"Original message:\", m1\nc1 = subs_cipher_encrypt(m1)\n\nprint\nprint \"Encrypted Message:\", c1\n\nprint\nprint \"Decrypted Message:\", subs_cipher_decrypt(c1)"}
{"cell_type":"code","execution_count":11,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Original message:\nTobeornottobethatisthequestionWhethertisNoblerinthemindtosufferTheSlingsandArrowsofoutrageousFortuneOrtotakeArmsagainstaSeaoftroublesAndbyopposingendthem\n\nEncrypted Message:\nVHMLHOCHVVHMLVAEVYRVALXPLRVYHCUALVALOVYRCHMTLOYCVALWYCSVHRPZZLOVALRTYCKRECSEOOHURHZHPVOEKLHPRZHOVPCLHOVHVEGLEOWREKEYCRVERLEHZVOHPMTLRECSMIHBBHRYCKLCSVALW\n\nDecrypted Message:\nTOBEORNOTTOBETHATISTHEQUESTIONWHETHERTISNOBLERINTHEMINDTOSUFFERTHESLINGSANDARROWSOFOUTRAGEOUSFORTUNEORTOTAKEARMSAGAINSTASEAOFTROUBLESANDBYOPPOSINGENDTHEM\n"}],"source":"print \"Original message:\"\nprint m\n\nprint\nc2 = subs_cipher_encrypt(m)\nprint \"Encrypted Message:\"\nprint c2\n\nprint\nprint \"Decrypted Message:\"\nprint subs_cipher_decrypt(c2)"}
{"cell_type":"markdown","metadata":{},"source":"Is this a good encryption scheme? Still no. In fact, these are routinely used as puzzles in newspapers or puzzle books, because given a reasonably long message, it's pretty easy to figure it out using things like the frequency of letters.\n\nFor instance, in English, the letters RSTLNEAO are very common, and much more common than other letters. So one might start to guess that the most common letter in the ciphertext is one of these. More powerfully, one might try to see which pairs of letters (called bigrams) are common, and look for those in the ciphertext, and so on.\n\nFrom this sort of thought process, encryption schemes that ultimately rely on a single secret alphabet (even if it's not our typical alphabet) fall pretty quickly. So... what about polyalphabetic ciphers? For instance, what if each group of 5 letters uses a different set of alphabets?\n\nThis is a great avenue for exploration, and there are lots of such encryption schemes that we won't discuss in this class. But a class on cryptography (or a book on cryptography) would certainly go into some of these. It might also be a reasonable avenue of exploration for a final project.\n\nThe German Enigma\n-------------------\n\nOne very well-known polyalphabetic encryption scheme is the **German Enigma** used before and during World War II. This was by far the most complicated cryptosystem in use up to that point, and the story of how it was broken is a long and tricky one. Intial successes towards breaking the Enigma came through the work of Polish mathematicians, fearful (and rightfully so) of the Germans across the border. By 1937, they had built replicas and understood many details of the Enigma system. But in 1938, the Germans shifted to a more secure and complicated cryptosystem. Just weeks before the German invasion of Poland and the beginning of World War II, Polish mathematicians sent their work and notes to mathematicians in France and Britain, who carried out this work.\n\nThe second major progress towards breaking the Enigma occurred largely in Bletchley Park in Britain, a communication center with an enormous dedicated effort to breaking the Enigma. This is where the tragic tale of Alan Turing, recently popularized through the movie *The Imitation Game*, begins. This is also the origin tale for modern computers, as Alan Turing developed electromechanical computers to help break the Enigma.\n\nThe Enigma worked by having a series of cogs or rotors whose positions determined a substitution cipher. After each letter, the positions were changed through a mechanical process. An Enigma machine is a very impressive machine to look at [and the \"computer\" Alan Turing used to help break them was also very impressive].\n\nBelow, I have implemented an Enigma, by default set to 4 rotors. I don't expect one to understand the implementation. The interesting part is how meaningless the output message looks. Note that I've kept the spacing and punctuation from the original message for easier comparison. Really, you wouldn't do this.\n\nThe plaintext used for demonstration is from Wikipedia's article on the Enigma."}
{"cell_type":"code","execution_count":12,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Original Message:\nWHEN PLACED IN AN ENIGMA, EACH ROTOR CAN BE SET TO ONE OF 26 POSSIBLE POSITIONS. WHEN INSERTED, IT CAN BE TURNED BY HAND USING THE GROOVED FINGER-WHEEL, WHICH PROTRUDES FROM THE INTERNAL ENIGMA COVER WHEN CLOSED. SO THAT THE OPERATOR CAN KNOW THE ROTOR'S POSITION, EACH HAD AN ALPHABET TYRE (OR LETTER RING) ATTACHED TO THE OUTSIDE OF THE ROTOR DISK, WITH 26 CHARACTERS (TYPICALLY LETTERS); ONE OF THESE COULD BE SEEN THROUGH THE WINDOW, THUS INDICATING THE ROTATIONAL POSITION OF THE ROTOR. IN EARLY MODELS, THE ALPHABET RING WAS FIXED TO THE ROTOR DISK. A LATER IMPROVEMENT WAS THE ABILITY TO ADJUST THE ALPHABET RING RELATIVE TO THE ROTOR DISK. THE POSITION OF THE RING WAS KNOWN AS THE RINGSTELLUNG (\"RING SETTING\"), AND WAS A PART OF THE INITIAL SETTING PRIOR TO AN OPERATING SESSION. IN MODERN TERMS IT WAS A PART OF THE INITIALIZATION VECTOR.\n\nEncrypted Message\nRYQY LWMVIH OH EK GGWFBO, PDZN FNALL ZEP AP IUD JM FEV UG 26 HGRKODYT XWOLIYTSA. TJQK KBCNVMHG, VS YBB XI BYZTVU XP BGWP IFNIY UQZ IQUPTKJ QXPVYE-EAOVT, PYMNN RXFIOWYVK LWNN OJL JXZBTRVP YMQCXX STJQF KXNZ LXSWDC. LK KGRH ZKT RDZUMCWA GKY LYKC LLV ZNFAD'Z BAXLDFTH, QSHA NBY RZ SXEXDAMP FXUS (WC RWHZOX ARWP) VKYNDJQP WL OLW ICBALPI RV ISD GXSDQ ZKMJ, OHNN 26 IBGUHNYIQE (GDBNTEBWP QGECUNA); QPG SQ JYUQX NDBWB NM AAUF RUNKYDL OLD LMPZQV, ZMKP SQZFDEHKCI KLJ AKPZLRAZZX QXPJEXLV HS AFG IIMGK. NT PVAYP RFOKYV, XUY CHZAQEXG DUSS CKN YENSR FX PLS CYMZK YHTB. J RLZLB DNIDWNWAIOO HOK PGM HVXXHIJ VV SCTNIC QGM TFKPQYPQ XFQU PSAECHTX RA QUW CUNRV JCUW. LCP GFKZLLXW LN YWF OAQM CMF YVTQH EI JAU LZTXEYDGDFLQ (\"CDBS TQHUEIR\"), BLN QIG O UHJJ DV DQY KQGVFKI EBEFRCT WEZWG LJ WC NIAUKIYQJ EHZLZLS. TY XPZSBL IPGWN ZS IUY E YQMD BW NVF QYWSDMTRSNSHYO GJGNUL.\n\nDecrypted Message:\nWHEN PLACED IN AN ENIGMA, EACH ROTOR CAN BE SET TO ONE OF 26 POSSIBLE POSITIONS. WHEN INSERTED, IT CAN BE TURNED BY HAND USING THE GROOVED FINGER-WHEEL, WHICH PROTRUDES FROM THE INTERNAL ENIGMA COVER WHEN CLOSED. SO THAT THE OPERATOR CAN KNOW THE ROTOR'S POSITION, EACH HAD AN ALPHABET TYRE (OR LETTER RING) ATTACHED TO THE OUTSIDE OF THE ROTOR DISK, WITH 26 CHARACTERS (TYPICALLY LETTERS); ONE OF THESE COULD BE SEEN THROUGH THE WINDOW, THUS INDICATING THE ROTATIONAL POSITION OF THE ROTOR. IN EARLY MODELS, THE ALPHABET RING WAS FIXED TO THE ROTOR DISK. A LATER IMPROVEMENT WAS THE ABILITY TO ADJUST THE ALPHABET RING RELATIVE TO THE ROTOR DISK. THE POSITION OF THE RING WAS KNOWN AS THE RINGSTELLUNG (\"RING SETTING\"), AND WAS A PART OF THE INITIAL SETTING PRIOR TO AN OPERATING SESSION. IN MODERN TERMS IT WAS A PART OF THE INITIALIZATION VECTOR.\n"}],"source":"from random import shuffle,randint,choice  \nfrom copy import copy  \nnum_alphabet = range(26)   \n    \ndef en_shift(l, n):                         # Rotate cogs and arrays\n    return l[n:] + l[:n]  \n      \n    \nclass Cog:                                  # Each cog has a substitution cipher  \n    def __init__(self):  \n        self.shuf = copy(num_alphabet)  \n        shuffle(self.shuf)                  # Create the individual substition cipher randomly\n        return                      # Really, these were not random, but were all chosen to be the same\n    \n    def subs_in(self,i):                    # Perform a substition\n        return self.shuf[i] \n    \n    def subs_out(self,i):                   # Perform a reverse substition\n        return self.shuf.index(i)\n    \n    def rotate(self):               # Rotate the cog by 1. Really, they could rotate by any number\n        self.shuf = en_shift(self.shuf, 1)\n        \n    def setcog(self,a):                     # Set up a particular substitution\n        self.shuf = a  \n\n        \nclass Enigma:  \n    def __init__(self, numcogs,readability=True):  \n        self.readability = readability  \n        self.numcogs = numcogs  \n        self.cogs = []  \n        self.oCogs = []                     # \"Original Cog positions\"  \n          \n        for i in range(0,self.numcogs):     # Create the cogs\n            self.cogs.append(Cog())\n            self.oCogs.append(self.cogs[i].shuf)  \n            \n        refabet = copy(num_alphabet) \n        self.reflector = copy(num_alphabet)  \n        while len(refabet) > 0:             # Pair letters in the reflector\n            a = choice(refabet)  \n            refabet.remove(a)  \n            \n            b = choice(refabet)  \n            refabet.remove(b)  \n            \n            self.reflector[a] = b  \n            self.reflector[b] = a\n            \n  \n    def print_setup(self): # Print out substituion setup.\n        print \"Enigma Setup:\\nCogs: \",self.numcogs,\"\\nCog arrangement:\"  \n        for i in range(0,self.numcogs):  \n            print self.cogs[i].shuf  \n        print \"Reflector arrangement:\\n\",self.reflector,\"\\n\"  \n          \n    def reset(self):  \n        for i in range(0,self.numcogs):  \n            self.cogs[i].setcog(self.oCogs[i])  \n              \n    def encode(self,text):  \n        t = 0     # Ticker counter  \n        ciphertext=\"\"  \n        for l in text.lower():  \n            num = ord(l) % 97  \n            # Handle special characters for readability\n            if (num>25 or num<0):  \n                if (self.readability):\n                    ciphertext += l   \n                else:  \n                    pass  \n            \n            else:\n                # Pass through cogs, reflect, then return through cogs\n                t += 1  \n                for i in range(self.numcogs): \n                    num = self.cogs[i].subs_in(num)  \n                      \n                num = self.reflector[num]  \n                  \n                for i in range(self.numcogs):  \n                    num = self.cogs[self.numcogs-i-1].subs_out(num)  \n                ciphertext += \"\" + chr(97+num)\n                  \n                # Rotate cogs\n                for i in range(self.numcogs):\n                    if ( t % ((i*6)+1) == 0 ):\n                        self.cogs[i].rotate()  \n        return ciphertext.upper()  \n  \nplaintext=\"\"\"When placed in an Enigma, each rotor can be set to one of 26 possible positions. \nWhen inserted, it can be turned by hand using the grooved finger-wheel, which protrudes from \nthe internal Enigma cover when closed. So that the operator can know the rotor's position, \neach had an alphabet tyre (or letter ring) attached to the outside of the rotor disk, with \n26 characters (typically letters); one of these could be seen through the window, thus indicating \nthe rotational position of the rotor. In early models, the alphabet ring was fixed to the rotor \ndisk. A later improvement was the ability to adjust the alphabet ring relative to the rotor disk. \nThe position of the ring was known as the Ringstellung (\"ring setting\"), and was a part of the \ninitial setting prior to an operating session. In modern terms it was a part of the \ninitialization vector.\"\"\"\n\n# Remove newlines for encryption\npt = \"\".join([l.upper() for l in plaintext if not l == \"\\n\"])\n# pt = \"\".join([l.upper() for l in plaintext if not l in punct])\n  \nx=Enigma(4)  \n#x.print_setup()  \n  \nprint \"Original Message:\"\nprint pt\n\nprint\nciphertext = x.encode(pt)  \nprint \"Encrypted Message\"\nprint ciphertext\n\nprint\n# Decryption and encryption are symmetric, so to decode we reset and re-encrypt.\nx.reset()  \ndecipheredtext = x.encode(ciphertext)  \nprint \"Decrypted Message:\"\nprint decipheredtext"}
{"cell_type":"markdown","metadata":{},"source":"The advent of computers brought in a paradigm shift in approaches towards cryptography. Prior to computers, one of the ways of maintaining security was to come up with a hidden key and a hidden cryptosystem, and keep it safe merely by not letting anyone know anything about how it actually worked at all. This has the short cute name **security through obscurity.** As the number of type of attacks on cryptosystems are much, much higher with computers, a different model of security and safety became necessary.\n\nIt is interesting to note that it is not obvious that security through obscurity is *always* bad, as long as it's *really really well-hidden.* This is relevant to some problems concerning current events and cryptography."}
{"cell_type":"markdown","metadata":{},"source":"Public Key Cryptography\n=============\n\nThe new model begins with a slightly different setup. We should think of Anabel and Bartolo as sitting on opposite sides of a classroom, trying to communicate securely even though there are lots of people in the middle of the classroom who might be listening in. In particular, Anabel has something she wants to tell Bartolo.\n\nInstead of keeping the cryptosystem secret, Bartolo tells everyone (in our metaphor, he shouts to the entire classroom) a public key K, and explains how to use it to send him a message. Anabel uses this key to encrypt her message. She then sends this message to Bartolo.\n\nIf the system is well-designed, no one will be able to understand the ciphertext even though they all know how the cryptosystem works. This is why the system is called **Public Key.**\n\nBartolo receives this message and (using something only he knows) he decrypts the message.\n\nWe will learn one such cryptosystem here: RSA, named after Rivest, Shamir, and Addleman --- the first major public key cryptosystem."}
{"cell_type":"markdown","metadata":{},"source":"RSA\n-----\n\nBartolo takes two primes such as $p = 12553$ and $q = 13007$. He notes their product\n$$m = pq = 163276871$$\nand computes $\\varphi(m)$,\n$$\\varphi(m) = (p-1)(q-1) = 163251312.$$\nFinally, he chooses some integer $k$ relatively prime to $\\varphi(m)$, like say\n$$k = 79921.$$\nThen the public key he distributes is\n$$ (m, k) = (163276871, 79921).$$\n\nIn order to send Bartolo a message using this key, Anabel must convert her message to numbers. She might use the identification A = 11, B = 12, C = 13, ... and concatenate her numbers. To send the word CAB, for instance, she would send 131112. Let's say that Anabel wants to send the message\n\nNUMBER THEORY IS THE QUEEN OF THE SCIENCES\n\nThen she needs to convert this to numbers."}
{"cell_type":"code","execution_count":13,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"conversion_dict = dict()\nalpha = \"abcdefghijklmnopqrstuvwxyz\".upper()\ncurnum = 11\nfor l in alpha:\n    conversion_dict[l] = curnum\n    curnum += 1"}
{"cell_type":"code","execution_count":14,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Original Message:\nNUMBERTHEORYISTHEQUEENOFTHESCIENCES\n\nNumerical Message:\n2431231215283018152528351929301815273115152425163018152913191524131529\n"}],"source":"print \"Original Message:\"\nmsg = \"NUMBERTHEORYISTHEQUEENOFTHESCIENCES\"\nprint msg\nprint\n\ndef letters_to_numbers(m):\n    return \"\".join([str(conversion_dict[l]) for l in m.upper()])\n\nprint \"Numerical Message:\"\nmsg_num = letters_to_numbers(msg)\nprint msg_num"}
{"cell_type":"markdown","metadata":{},"source":"So Anabel's message is the number\n\n$$2431231215283018152528351929301815273115152425163018152913191524131529$$\n\nwhich she wants to encrypt and send to Bartolo. To make this manageable, she cuts the message into 8-digit numbers,\n\n$$24312312, 15283018, 15252835, 19293018, 15273115, 15242516, 30181529, 13191524, 131529.$$\n\nTo send her message, she takes one of the 8-digit blocks and raises it to the power of $k$ modulo $m$. That is, to transmit the first block, she computes\n\n$$ 24312312^{79921} \\equiv 13851252 \\pmod{163276871}.$$"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":false,"scrolled":true,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"13851252\n"}],"source":"# Secret information\np = 12553\nq = 13007\nphi = (p-1)*(q-1) # varphi(pq)\n\n# Public information\nm = p*q # 163276871\nk = 79921\n\nprint pow(24312312, k, m)"}
{"cell_type":"markdown","metadata":{},"source":"She sends this number\n$$13851252$$\nto Bartolo (maybe by shouting. Even though everyone can hear, they cannot decrypt it). How does Bartolo decrypt this message?\n\nHe computes $\\varphi(m) = (p-1)(q-1)$ (which he can do because he knows $p$ and $q$ separately), and then finds a solution $u$ to\n$$ uk = 1 + \\varphi(m) v.$$\nThis can be done quickly through the Euclidean Algorithm."}
{"cell_type":"code","execution_count":16,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def extended_euclidean(a,b):\n    if b == 0:\n        return (1,0,a)\n    else :\n        x, y, gcd = extended_euclidean(b, a % b) # Aside: Python has no tail recursion\n        return y, x - y * (a // b),gcd           # But it does have meaningful stack traces\n    \n# This version comes from Exercise 6.3 in the book, but without recursion\ndef extended_euclidean2(a,b):\n    x = 1\n    g = a\n    v = 0\n    w = b\n    while w != 0:\n        q = g // w\n        t = g - q*w\n        s = x - q*v\n        x,g = v,w\n        v,w = s,t\n    y = (g - a*x) / b\n    return (x,y,g)\n \ndef modular_inverse(a,m) :\n    x,y,gcd = extended_euclidean(a,m)\n    if gcd == 1 :\n        return x % m\n    else :\n        return None"}
{"cell_type":"code","execution_count":17,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"k, p, q: 79921 12553 13007\n\n145604785\n"}],"source":"print \"k, p, q:\", k, p, q\nprint\nu = modular_inverse(k,(p-1)*(q-1))\nprint u"}
{"cell_type":"markdown","metadata":{},"source":"In particular, Bartolo computes that his $u = 145604785$. To recover the message, he takes the number $13851252$ sent to him by Anabel and raises it to the $u$ power. He computes\n$$ 13851252^{u} \\equiv 24312312 \\pmod{pq},$$\nwhich we can see must be true as\n$$ 13851252^{u} \\equiv (24312312^{k})^u \\equiv 24312312^{1 + \\varphi(pq)v} \\equiv 24312312 \\pmod{pq}.$$\nIn this last step, we have used Euler's Theorem to see that\n$$ 24312312^{\\varphi(pq)v} \\equiv 1 \\pmod{pq}.$$\n"}
{"cell_type":"code","execution_count":18,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"24312312\n"}],"source":"# Checking this power explicitly.\nprint pow(13851252, 145604785, m)"}
{"cell_type":"markdown","metadata":{},"source":"Now Bartolo needs to perform this process for each 8-digit chunk that Anabel sent over. Note that the work is very easy, as he computes the integer $u$ only once. Each other time, he simply computes $c^u \\pmod m$ for each ciphertext $c$, and this is very fast with repeated-squaring.\n\nWe do this below, in an automated fashion, step by step.\n\nFirst, we split the message into 8-digit chunks."}
{"cell_type":"code","execution_count":19,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"['24312312', '15283018', '15252835', '19293018', '15273115', '15242516', '30181529', '13191524', '131529']\n"}],"source":"# Break into chunks of 8 digits in length.\ndef chunk8(message_number):\n    cp = str(message_number)\n    ret_list = []\n    while len(cp) > 7:\n        ret_list.append(cp[:8])\n        cp = cp[8:]\n    if cp:\n        ret_list.append(cp)\n    return ret_list\n\nmsg_list = chunk8(msg_num)\nprint msg_list"}
{"cell_type":"markdown","metadata":{},"source":"This is a numeric representation of the message Anabel wants to send Bartolo. So she encrypts each chunk. This is done below"}
{"cell_type":"code","execution_count":20,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[13851252, 14944940, 158577269, 117640431, 139757098, 25099917, 88562046, 6640362, 10543199]\n"}],"source":"# Compute ciphertexts separately on each 8-digit chunk.\ndef encrypt_chunks(chunked_list):\n    ret_list = []\n    for chunk in chunked_list:\n        #print chunk\n        #print int(chunk)\n        ret_list.append(pow(int(chunk), k, m))\n    return ret_list\n\ncipher_list = encrypt_chunks(msg_list)\nprint cipher_list"}
{"cell_type":"markdown","metadata":{},"source":"This is the encrypted message. Having computed this, Anabel sends this message to Bartolo.\n\nTo decrypt the message, Bartolo uses his knowledge of $u$, which comes from his ability to compute $\\varphi(pq)$, and decrypts each part of the message. This looks like below."}
{"cell_type":"code","execution_count":21,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[24312312, 15283018, 15252835, 19293018, 15273115, 15242516, 30181529, 13191524, 131529]\n"}],"source":"# Decipher the ciphertexts all in the same way\ndef decrypt_chunks(chunked_list):\n    ret_list = []\n    for chunk in chunked_list:\n        ret_list.append(pow(int(chunk), u, m))\n    return ret_list\n\ndecipher_list = decrypt_chunks(cipher_list)\nprint decipher_list"}
{"cell_type":"markdown","metadata":{},"source":"Finally, Bartolo concatenates these numbers together and translates them back into letters. Will he get the right message back?"}
{"cell_type":"code","execution_count":22,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"NUMBERTHEORYISTHEQUEENOFTHESCIENCES\n"}],"source":"alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n# Collect deciphered texts into a single list, and translate back into letters.\ndef chunks_to_letters(chunked_list):\n    s = \"\".join([str(chunk) for chunk in chunked_list])\n    ret_str = \"\"\n    while s:\n        ret_str += alpha[int(s[:2])-11].upper()\n        s = s[2:]\n    return ret_str\n\nprint chunks_to_letters(decipher_list)"}
{"cell_type":"markdown","metadata":{},"source":"Yes! Bartolo successfully decrypts the message and sees that Anabel thinks that **Number Theory is the Queen of the Sciences.** This is a quote from Gauss, the famous mathematician who has been popping up again and again in this course."}
{"cell_type":"markdown","metadata":{},"source":""}
{"cell_type":"markdown","metadata":{},"source":"Condensed Version\n--------------------\n\nNow that we've gone through it all once, we have a condensed RSA system set up with our $p, q,$ and $k$ from above. To show that this can be done quickly with a computer, let's do another right now.\n\nLet us encrypt, transmit, and decrypt the message\n\n\"I have never done anything useful. No discovery of mine has made, or is likely to make, directly or indirectly, for good or ill, the least difference to the amenity of the world\".\n\nFirst, we prepare the message for conversion to numbers."}
{"cell_type":"code","execution_count":23,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Our message:\nIHAVENEVERDONEANYTHINGUSEFULNODISCOVERYOFMINEHASMADEORISLIKELYTOMAKEDIRECTLYORINDIRECTLYFORGOODORILLTHELEASTDIFFERENCETOTHEAMENITYOFTHEWORLD\n"}],"source":"message = \"\"\"I have never done anything useful. No discovery of mine has made, \nor is likely to make, directly or indirectly, for good or ill, the least \ndifference to the amenity of the world\"\"\"\n\nmessage = \"\".join([l.upper() for l in message if not l in \"\\n .,\"])\nprint \"Our message:\\n\"+message"}
{"cell_type":"markdown","metadata":{},"source":"Now we convert the message to numbers, and transform those numbers into 8-digit chunks."}
{"cell_type":"code","execution_count":24,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Our message, converted to numbers:\n1918113215241532152814252415112435301819241731291516312224251419291325321528352516231924151811292311141525281929221921152235302523112115141928151330223525281924141928151330223516252817252514252819222230181522151129301419161615281524131530253018151123152419303525163018153325282214\n\nSeparated into 8-digit chunks:\n['19181132', '15241532', '15281425', '24151124', '35301819', '24173129', '15163122', '24251419', '29132532', '15283525', '16231924', '15181129', '23111415', '25281929', '22192115', '22353025', '23112115', '14192815', '13302235', '25281924', '14192815', '13302235', '16252817', '25251425', '28192222', '30181522', '15112930', '14191616', '15281524', '13153025', '30181511', '23152419', '30352516', '30181533', '25282214']\n"}],"source":"numerical_message = letters_to_numbers(message)\nprint \"Our message, converted to numbers:\"\nprint numerical_message\nprint\n\nplaintext_chunks = chunk8(numerical_message)\nprint \"Separated into 8-digit chunks:\"\nprint plaintext_chunks"}
{"cell_type":"markdown","metadata":{},"source":"We encrypt each chunk by computing $P^k \\bmod {m}$ for each plaintext chunk $P$."}
{"cell_type":"code","execution_count":25,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[99080958, 142898385, 80369161, 11935375, 108220081, 82708130, 158605094, 96274325, 154177847, 121856444, 91409978, 47916550, 155466420, 92033719, 95710042, 86490776, 15468891, 139085799, 68027514, 53153945, 139085799, 68027514, 9216376, 155619290, 83776861, 132272900, 57738842, 119368739, 88984801, 83144549, 136916742, 13608445, 92485089, 89508242, 25375188]\n"}],"source":"ciphertext_chunks = encrypt_chunks(plaintext_chunks)\nprint ciphertext_chunks"}
{"cell_type":"markdown","metadata":{},"source":"This is the message that Anabel can sent Bartolo.\n\nTo decrypt it, he computes $c^u \\bmod m$ for each ciphertext chunk $c$."}
{"cell_type":"code","execution_count":26,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Deciphered chunks:\n[19181132, 15241532, 15281425, 24151124, 35301819, 24173129, 15163122, 24251419, 29132532, 15283525, 16231924, 15181129, 23111415, 25281929, 22192115, 22353025, 23112115, 14192815, 13302235, 25281924, 14192815, 13302235, 16252817, 25251425, 28192222, 30181522, 15112930, 14191616, 15281524, 13153025, 30181511, 23152419, 30352516, 30181533, 25282214]\n"}],"source":"deciphered_chunks = decrypt_chunks(ciphertext_chunks)\nprint \"Deciphered chunks:\"\nprint deciphered_chunks"}
{"cell_type":"markdown","metadata":{},"source":"Finally, he translates the chunks back into letters."}
{"cell_type":"code","execution_count":27,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Decoded Message:\nIHAVENEVERDONEANYTHINGUSEFULNODISCOVERYOFMINEHASMADEORISLIKELYTOMAKEDIRECTLYORINDIRECTLYFORGOODORILLTHELEASTDIFFERENCETOTHEAMENITYOFTHEWORLD\n"}],"source":"decoded_message = chunks_to_letters(deciphered_chunks)\nprint \"Decoded Message:\"\nprint decoded_message"}
{"cell_type":"markdown","metadata":{},"source":"Even with large numbers, RSA is pretty fast. But one of the key things that one can do with RSA is securely transmit secret keys for other types of faster-encryption that don't work in a public-key sense. There is a lot of material in this subject, and it's very important.\n\nThe study of sending and receiving secret messages is called **Cryptography.** There are lots of interesting related topics, some of which we'll touch on in class.\n\nThe study of analyzing and breaking cryptosystems is called **Cryptanalysis,** and is something I find quite fun. But it's also quite intense.\n\nI should mention that in practice, RSA is performed a little bit differently to make it more secure."}