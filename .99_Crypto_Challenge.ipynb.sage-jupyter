{"kernelspec":{"display_name":"Python 2 (Ubuntu, plain)","language":"python","name":"python2-ubuntu"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# The crypto challenge\nhttps://cryptopals.com/\n\n這個Challenge十分有趣，有點類似crypto的capture the flag\n\n應該很少人學樂器、打球、繪畫認為翻翻書就可以了\n\n程式也一樣 密碼學也一樣 所以實作吧...\n\nToDo: SHA 部分未完成\n\n# Set1\n\n### Challenge1 - Convert between encoding\n雖然說是密碼學，不過第一個set大多是在處理資料轉換\n\n> 處理 ``raw bytes`` 不要 encode 之後再處理， base64和 hex是印出來給大家看用的\n\n用``binascii`` 這個函式庫做資料轉換\n\n```\nbytes([text[i] ^ text[32 + i] for i in range(16)]) <-> \"\".join([text[i] ^ text[32 + i] for i in range(16)])\nbytes([text[i] ^ text[32 + i] for i in range(16)]) <-> bytearray([text[i] ^ text[32 + i] for i in range(16)])\nbytes([text[i]]) <-> chr(text[i])\n```"}
{"cell_type":"code","execution_count":19,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"I'm killing your brain like a poisonous mushroom\nI'm killing your brain like a poisonous mushroom\n49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d\nSSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t\nSSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t\n\n"}],"source":"import Crypto\nimport binascii\nimport base64\n\nx = '49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d' # raw hex\nexpectedY = 'SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t' # base64\ndecoded = binascii.unhexlify(x) # 傳回ascii string \nprint decoded\nprint base64.b64decode(expectedY)\nprint decoded.encode('hex')\nprint base64.b64encode(decoded)\nprint decoded.encode('base64') # 有帶換行\ny = base64.b64encode(decoded)\nif y != expectedY:\n    raise Exception(y + ' != ' + expectedY)"}
{"cell_type":"code","execution_count":20,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"I'm killing your brain like a poisonous mushroom\nSSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t\n\n"}],"source":"from binascii import a2b_hex, b2a_base64\n## a2b_hex == binascii.unhexlify\nprint a2b_hex(x) \nprint b2a_base64(a2b_hex(x))"}
{"cell_type":"markdown","metadata":{},"source":"### Challeng2 - Fixed XOR\n\n將兩個等長度的字串做XOR"}
{"cell_type":"code","execution_count":21,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"the kid don't play\nthe kid don't play\n"}],"source":"from Crypto.Util.strxor import strxor\n\nencodedS = '1c0111001f010100061a024b53535009181c' # 相同長度\nencodedT = '686974207468652062756c6c277320657965'\nencodedExpectedU = '746865206b696420646f6e277420706c6179'\n\ns = binascii.unhexlify(encodedS)\nt = binascii.unhexlify(encodedT)\nexpectedU = binascii.unhexlify(encodedExpectedU)\n\nu = strxor(s, t)\nprint u\nprint expectedU"}
{"cell_type":"markdown","metadata":{},"source":"也許可用syntax sugar但crypto每一function都要小心運用"}
{"cell_type":"code","execution_count":22,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"0x746865206b696420646f6e277420706c6179L\n"},{"data":{"text/plain":"'0x746865206B696420646F6E277420706C6179'"},"execution_count":22,"metadata":{},"output_type":"execute_result"}],"source":"print hex(int(encodedS, 16)^int(encodedT, 16))\n\"0x%0.2X\" % (int(encodedS, 16)^int(encodedT, 16))"}
{"cell_type":"markdown","metadata":{},"source":"## Frequency of Characters\n### Challenge 3 - Single-byte XOR cipher\n\n實做我們的第一個cipher，並用著名的頻率分析攻擊法來破解，也就是說程式在求解的過程中怎樣才知道他解對了?\n\n用英文字母的頻率來猜看看最有可能的``plaintext``"}
{"cell_type":"code","execution_count":23,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"'\\x1b77316?x\\x15\\x1b\\x7f+x413=x9x(7-6<x7>x:9;76'"},"execution_count":23,"metadata":{},"output_type":"execute_result"}],"source":"from Crypto.Util.strxor import strxor_c\nimport binascii\nfrom Crypto.Util.strxor import strxor_c\n\n# From http://www.data-compression.com/english.html\nfreqs = {\n    'a': 0.0651738,\n    'b': 0.0124248,\n    'c': 0.0217339,\n    'd': 0.0349835,\n    'e': 0.1041442,\n    'f': 0.0197881,\n    'g': 0.0158610,\n    'h': 0.0492888,\n    'i': 0.0558094,\n    'j': 0.0009033,\n    'k': 0.0050529,\n    'l': 0.0331490,\n    'm': 0.0202124,\n    'n': 0.0564513,\n    'o': 0.0596302,\n    'p': 0.0137645,\n    'q': 0.0008606,\n    'r': 0.0497563,\n    's': 0.0515760,\n    't': 0.0729357,\n    'u': 0.0225134,\n    'v': 0.0082903,\n    'w': 0.0171272,\n    'x': 0.0013692,\n    'y': 0.0145984,\n    'z': 0.0007836,\n    ' ': 0.1918182 \n}\n\ndef score(s):\n    score = 0\n    for i in s:\n        c = i.lower()\n        if c in freqs:\n            score += freqs[c]\n    return score\n\nencodedS = '1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736'\ns = binascii.unhexlify(encodedS)\ns"}
{"cell_type":"code","execution_count":24,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[88, \"Cooking MC's like a pound of bacon\"]\n"}],"source":"def breakSingleByteXOR(s):\n    curr_score = 0\n    best_str = \"\"\n    number = 0\n    for i in range(0, 256):\n        if(score(strxor_c(s, i)) > curr_score):\n            best_str = strxor_c(s, i)\n            curr_score = score(strxor_c(s, i))\n            number = i\n    return [number, best_str]\n\n\nprint breakSingleByteXOR(s)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge4 - Detecting the single char\n\n接下來找出檔案中用的加密字母吧!"}
{"cell_type":"code","execution_count":25,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Now that the party is jumping\n\n"}],"source":"import binascii\n\ndef decodeLines(filename):\n    f = open(filename, 'r')\n    for line in f:\n        if line[-1] == '\\n':\n            line = line[:-1]\n        s = binascii.unhexlify(line)\n        yield s\n\ndef findSingleByteXOR(lines):\n    brokenLines = [breakSingleByteXOR(l)[1] for l in lines]\n    curr_score = 0\n    number = 0\n    best_str = \"\"\n    for i in range(len(brokenLines)):\n        if score(brokenLines[i]) > curr_score:\n            curr_score = score(brokenLines[i])\n            best_str =  brokenLines[i]\n    return best_str\n\nprint findSingleByteXOR(decodeLines('Text/4.txt'))"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 5 - Repeating-key XOR\n\n這是一首古老的英文詩:\n\n```\nBurning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal\n```\n\n用 \"ICE\" 來對他做循環XOR 加密!\n\n在此加密法值中，我們循序用\"I\"加密第一個byte，用\"C\"加密第二個byte，\"E\"加密第三個byte，再用\"I\"加密第四個byte...\n\n\n> ord('') 得到ascii值, chr(97) 得到ascii字元"}
{"cell_type":"code","execution_count":26,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f\n"}],"source":"import binascii\nfrom Crypto.Util.strxor import strxor_c\n\ndef encodeRepeatingKeyXor(s, key):\n    return \"\".join([strxor_c(x[i] , ord(key[i % len(key)])) for i in range(len(x))])\n\nx = b'''Burning 'em, if you ain't quick and nimble\nI go crazy when I hear a cymbal'''\nkey = b'ICE'\nencodedExpectedY = '0b3637272a2b2e63622c2e69692a23693a2a3c6324202d623d63343c2a26226324272765272a282b2f20430a652e2c652a3124333a653e2b2027630c692b20283165286326302e27282f'\nY = encodeRepeatingKeyXor(x, key)\nencodedY = Y.encode('hex')\nprint encodedY\nif encodedY != encodedExpectedY:\n    raise Exception(encodedY + ' != ' + encodedExpectedY)"}
{"cell_type":"markdown","metadata":{},"source":"###  challenge 6 - Break the repeating XOR\n\nchallenge 6 是破解 Vigenere Cipher\n\n1. 假設 KEYSIZE 在 2 到 40之間.\n2. 寫一個 function來計算兩字串間的 edit distance/Hamming distance 例如: this is a test 和 wokka wokka!!! 的距離是37(先確認我們的function是否正確)\n3. 對於每一個假設長度，我們找出最可能的key長度(看slice後的hamming distance最小者)，注意要除以 KEYSIZE 來Normalized結果!\n4. 可以拿最小和次小者來試驗，或算更多 KEYSIZE block之間的hamming distance!\n"}
{"cell_type":"code","execution_count":27,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"37\n"}],"source":"import base64\nimport itertools\nfrom Crypto.Util.strxor import strxor\n\ndef getHammingDistance(x, y):\n    return sum([bin(ord(x[i]) ^ ord(y[i])).count('1') for i in range(len(x))])\n\nx = b'this is a test'\ny = b'wokka wokka!!!'\nexpectedD = 37\nd = getHammingDistance(x, y)\nprint d\nif d != expectedD:\n    raise Exception(encodedD + ' != ' + encodedExpectedD)"}
{"cell_type":"code","execution_count":28,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"29"},"execution_count":28,"metadata":{},"output_type":"execute_result"}],"source":"x = base64.b64decode(open('Text/6.txt', 'r').read())\ndef breakRepeatingKeyXor(x, k):\n    blockstring = []\n    blocks = [x[i:i+k] for i in range(0, len(x), k)]\n    transposedBlocks = list(itertools.izip_longest(*blocks, fillvalue='0'))\n    for i in range(len(transposedBlocks)):\n        tmpblock = \"\".join([a for a in transposedBlocks[i]])\n        blockstring.append(tmpblock)\n    key = \"\".join([chr(breakSingleByteXOR(x)[0]) for x in blockstring])\n    return key\n\ndef normalizedEditDistance(x, k):\n    blocks = [x[i:i+k] for i in range(0, len(x), k)][0:4]\n    pairs = list(itertools.combinations(blocks, 2))\n    scores = [getHammingDistance(p[0], p[1])/float(k) for p in pairs][0:6]\n    return sum(scores) / len(scores)\n\nk = min(range(2, 41), key=lambda k: normalizedEditDistance(x, k))\nk"}
{"cell_type":"markdown","metadata":{},"source":"5. 拿此KEYSIZE來破 \n6. 接下來用此 KEYSIZE將原文slice後分成k組逐一攻破\n7. 對每一組使用single-character XOR攻擊法\n8. 解出所有的key"}
{"cell_type":"code","execution_count":29,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Terminator X: Bring the noise\nI'm back and I'm ringin' the bell \nA rockin' on the mike while the fly girls yell \nIn ecstasy in the back of me \nWell that's my DJ Deshay cuttin' all them Z's \nHittin' hard and the girlies goin' crazy \nVanilla's on the mike, man I'm not lazy. \n\nI'm lettin' my drug kick in \nIt controls my mouth and I begin \nTo just let it flow, let my concepts go \nMy posse's to the side yellin', Go Vanilla Go! \n\nSmooth 'cause that's the way I will be \nAnd if you don't give a damn, then \nWhy you starin' at me \nSo get off 'cause I control the stage \nThere's no dissin' allowed \nI'm in my own phase \nThe girlies sa y they love me and that is ok \nAnd I can dance better than any kid n' play \n\nStage 2 -- Yea the one ya' wanna listen to \nIt's off my head so let the beat play through \nSo I can funk it up and make it sound good \n1-2-3 Yo -- Knock on some wood \nFor good luck, I like my rhymes atrocious \nSupercalafragilisticexpialidocious \nI'm an effect and that you can bet \nI can take a fly girl and make her wet. \n\nI'm like Samson -- Samson to Delilah \nThere's no denyin', You can try to hang \nBut you'll keep tryin' to get my style \nOver and over, practice makes perfect \nBut not if you're a loafer. \n\nYou'll get nowhere, no place, no time, no girls \nSoon -- Oh my God, homebody, you probably eat \nSpaghetti with a spoon! Come on and say it! \n\nVIP. Vanilla Ice yep, yep, I'm comin' hard like a rhino \nIntoxicating so you stagger like a wino \nSo punks stop trying and girl stop cryin' \nVanilla Ice is sellin' and you people are buyin' \n'Cause why the freaks are jockin' like Crazy Glue \nMovin' and groovin' trying to sing along \nAll through the ghetto groovin' this here song \nNow you're amazed by the VIP posse. \n\nSteppin' so hard like a German Nazi \nStartled by the bases hittin' ground \nThere's no trippin' on mine, I'm just gettin' down \nSparkamatic, I'm hangin' tight like a fanatic \nYou trapped me once and I thought that \nYou might have it \nSo step down and lend me your ear \n'89 in my time! You, '90 is my year. \n\nYou're weakenin' fast, YO! and I can tell it \nYour body's gettin' hot, so, so I can smell it \nSo don't be mad and don't be sad \n'Cause the lyrics belong to ICE, You can call me Dad \nYou're pitchin' a fit, so step back and endure \nLet the witch doctor, Ice, do the dance to cure \nSo come up close and don't be square \nYou wanna battle me -- Anytime, anywhere \n\nYou thought that I was weak, Boy, you're dead wrong \nSo come on, everybody and sing this song \n\nSay -- Play that funky music Say, go white boy, go white boy go \nplay that funky music Go white boy, go white boy, go \nLay down and boogie and play that funky music till you die. \n\nPlay that funky music Come on, Come on, let me hear \nPlay that funky music white boy you say it, say it \nPlay that funky music A little louder now \nPlay that funky music, white boy Come on, Come on, Come on \nPlay that funky music \n\n"}],"source":"key = breakRepeatingKeyXor(x, k)\ny = encodeRepeatingKeyXor(x, key)\nprint key\nprint y"}
{"cell_type":"markdown","metadata":{},"source":"## AES\n### Challenge8\n\n簡單的用Pycrypto AES練習"}
{"cell_type":"code","execution_count":30,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"I'm back and I'm ringin' the bell \nA rockin' on the mike while the fly girls yell \nIn ecstasy in the back of me \nWell that's my DJ Deshay cuttin' all them Z's \nHittin' hard and the girlies goin' crazy \nVanilla's on the mike, man I'm not lazy. \n\nI'm lettin' my drug kick in \nIt controls my mouth and I begin \nTo just let it flow, let my concepts go \nMy posse's to the side yellin', Go Vanilla Go! \n\nSmooth 'cause that's the way I will be \nAnd if you don't give a damn, then \nWhy you starin' at me \nSo get off 'cause I control the stage \nThere's no dissin' allowed \nI'm in my own phase \nThe girlies sa y they love me and that is ok \nAnd I can dance better than any kid n' play \n\nStage 2 -- Yea the one ya' wanna listen to \nIt's off my head so let the beat play through \nSo I can funk it up and make it sound good \n1-2-3 Yo -- Knock on some wood \nFor good luck, I like my rhymes atrocious \nSupercalafragilisticexpialidocious \nI'm an effect and that you can bet \nI can take a fly girl and make her wet. \n\nI'm like Samson -- Samson to Delilah \nThere's no denyin', You can try to hang \nBut you'll keep tryin' to get my style \nOver and over, practice makes perfect \nBut not if you're a loafer. \n\nYou'll get nowhere, no place, no time, no girls \nSoon -- Oh my God, homebody, you probably eat \nSpaghetti with a spoon! Come on and say it! \n\nVIP. Vanilla Ice yep, yep, I'm comin' hard like a rhino \nIntoxicating so you stagger like a wino \nSo punks stop trying and girl stop cryin' \nVanilla Ice is sellin' and you people are buyin' \n'Cause why the freaks are jockin' like Crazy Glue \nMovin' and groovin' trying to sing along \nAll through the ghetto groovin' this here song \nNow you're amazed by the VIP posse. \n\nSteppin' so hard like a German Nazi \nStartled by the bases hittin' ground \nThere's no trippin' on mine, I'm just gettin' down \nSparkamatic, I'm hangin' tight like a fanatic \nYou trapped me once and I thought that \nYou might have it \nSo step down and lend me your ear \n'89 in my time! You, '90 is my year. \n\nYou're weakenin' fast, YO! and I can tell it \nYour body's gettin' hot, so, so I can smell it \nSo don't be mad and don't be sad \n'Cause the lyrics belong to ICE, You can call me Dad \nYou're pitchin' a fit, so step back and endure \nLet the witch doctor, Ice, do the dance to cure \nSo come up close and don't be square \nYou wanna battle me -- Anytime, anywhere \n\nYou thought that I was weak, Boy, you're dead wrong \nSo come on, everybody and sing this song \n\nSay -- Play that funky music Say, go white boy, go white boy go \nplay that funky music Go white boy, go white boy, go \nLay down and boogie and play that funky music till you die. \n\nPlay that funky music Come on, Come on, let me hear \nPlay that funky music white boy you say it, say it \nPlay that funky music A little louder now \nPlay that funky music, white boy Come on, Come on, Come on \nPlay that funky music \n\u0004\u0004\u0004\u0004\n"}],"source":"import base64\nfrom Crypto.Cipher import AES\n\nx = base64.b64decode(open('Text/7.txt', 'r').read())\n\nkey = b'YELLOW SUBMARINE'\ncipher = AES.new(key, AES.MODE_ECB)\ny = cipher.decrypt(x)\nprint(y)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge9"}
{"cell_type":"code","execution_count":32,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"133\n"}],"source":"import itertools\n\nlines = decodeLines('Text/8.txt')\n\ndef score(x):\n    k = 16\n    blocks = [x[i:i+k] for i in range(0, len(x), k)]\n    pairs = itertools.combinations(blocks, 2)\n    same = 0\n    count = 0\n    for p in pairs:\n        if p[0] == p[1]:\n            same += 1\n    return same\n\nlineNumber = 1\nfor l in lines:\n    if score(l) > 0:\n        print(lineNumber)\n    lineNumber += 1"}
{"cell_type":"markdown","metadata":{},"source":"# Set 2\n## Padding\n### Challenge 9 - Implement PKCS#7 padding\n\n比較下列在python 2.7的行為"}
{"cell_type":"code","execution_count":33,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"('a', '\\x04', '4')"},"execution_count":33,"metadata":{},"output_type":"execute_result"}],"source":"chr(97), chr(4), str(4)"}
{"cell_type":"markdown","metadata":{},"source":"pad 任何區塊到特定長度， 在block最後說明我們pad了多長，例如:\n\n```\n\"YELLOW SUBMARINE\"\n```\npadded 到 20 bytes \n\n```\n\"YELLOW SUBMARINE\\x04\\x04\\x04\\x04\"\n```\n\n另外先建立一個亂數產生器(接下來會經常用到!!)"}
{"cell_type":"code","execution_count":36,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"YELLOW SUBMARINE\u0004\u0004\u0004\u0004\nYELLOW SUBMARINE\u0004\u0004\u0004\u0004\n"}],"source":"from Crypto.Random import random\n\ndef to_bytes(n, length, endianess='big'):\n    h = '%x' % n\n    s = ('0'*(len(h) % 2) + h).zfill(length*2).decode('hex')\n    return s if endianess == 'big' else s[::-1]\n\ndef randbytes(k):\n    return to_bytes(random.getrandbits(8*k), k)\n\ndef padPKCS7(x, k):\n    ch = k - (len(x) % k)\n    return x + chr(ch) * ch\n\n\nx = b'YELLOW SUBMARINE'\nexpectedY = b'YELLOW SUBMARINE\\x04\\x04\\x04\\x04'\ny = padPKCS7(x, 20)\n\nprint y\nprint expectedY\n\nif y != expectedY:\n    raise Exception(y + b' != ' + expectedY)"}
{"cell_type":"code","execution_count":37,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"4924570563036422340\n"},{"data":{"text/plain":"'\\x1e\\xd6\\x98A\\xad\\xfbP\\xab'"},"execution_count":37,"metadata":{},"output_type":"execute_result"}],"source":"print random.getrandbits(8*8)\nrandbytes(8)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge10 - Implement CBC mode\n\n用ECB建構出CBC一開始的IV 用 ``all ASCII 0 (\\x00\\x00\\x00 &c)``\n\n![](https://i.imgur.com/dF9LU1z.png)"}
{"cell_type":"code","execution_count":39,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"I'm back and I'm ringin' the bell \nA rockin' on the mike while the fly girls yell \nIn ecstasy in the back of me \nWell that's my DJ Deshay cuttin' all them Z's \nHittin' hard and the girlies goin' crazy \nVanilla's on the mike, man I'm not lazy. \n\nI'm lettin' my drug kick in \nIt controls my mouth and I begin \nTo just let it flow, let my concepts go \nMy posse's to the side yellin', Go Vanilla Go! \n\nSmooth 'cause that's the way I will be \nAnd if you don't give a damn, then \nWhy you starin' at me \nSo get off 'cause I control the stage \nThere's no dissin' allowed \nI'm in my own phase \nThe girlies sa y they love me and that is ok \nAnd I can dance better than any kid n' play \n\nStage 2 -- Yea the one ya' wanna listen to \nIt's off my head so let the beat play through \nSo I can funk it up and make it sound good \n1-2-3 Yo -- Knock on some wood \nFor good luck, I like my rhymes atrocious \nSupercalafragilisticexpialidocious \nI'm an effect and that you can bet \nI can take a fly girl and make her wet. \n\nI'm like Samson -- Samson to Delilah \nThere's no denyin', You can try to hang \nBut you'll keep tryin' to get my style \nOver and over, practice makes perfect \nBut not if you're a loafer. \n\nYou'll get nowhere, no place, no time, no girls \nSoon -- Oh my God, homebody, you probably eat \nSpaghetti with a spoon! Come on and say it! \n\nVIP. Vanilla Ice yep, yep, I'm comin' hard like a rhino \nIntoxicating so you stagger like a wino \nSo punks stop trying and girl stop cryin' \nVanilla Ice is sellin' and you people are buyin' \n'Cause why the freaks are jockin' like Crazy Glue \nMovin' and groovin' trying to sing along \nAll through the ghetto groovin' this here song \nNow you're amazed by the VIP posse. \n\nSteppin' so hard like a German Nazi \nStartled by the bases hittin' ground \nThere's no trippin' on mine, I'm just gettin' down \nSparkamatic, I'm hangin' tight like a fanatic \nYou trapped me once and I thought that \nYou might have it \nSo step down and lend me your ear \n'89 in my time! You, '90 is my year. \n\nYou're weakenin' fast, YO! and I can tell it \nYour body's gettin' hot, so, so I can smell it \nSo don't be mad and don't be sad \n'Cause the lyrics belong to ICE, You can call me Dad \nYou're pitchin' a fit, so step back and endure \nLet the witch doctor, Ice, do the dance to cure \nSo come up close and don't be square \nYou wanna battle me -- Anytime, anywhere \n\nYou thought that I was weak, Boy, you're dead wrong \nSo come on, everybody and sing this song \n\nSay -- Play that funky music Say, go white boy, go white boy go \nplay that funky music Go white boy, go white boy, go \nLay down and boogie and play that funky music till you die. \n\nPlay that funky music Come on, Come on, let me hear \nPlay that funky music white boy you say it, say it \nPlay that funky music A little louder now \nPlay that funky music, white boy Come on, Come on, Come on \nPlay that funky music \n\u0004\u0004\u0004\u0004\n"}],"source":"import base64\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.strxor import strxor\n\nclass CBC:\n    def __init__(self, ECB, IV):\n        self._ECB = ECB\n        self._IV = IV\n        self._blocksize = 16\n\n    def _getBlocks(self, s):\n        return [s[i:i+self._blocksize] for i in range(0, len(s), self._blocksize)]\n\n    def encrypt(self, plaintext):\n        plainblocks = self._getBlocks(plaintext)\n        ciphertext = b'' #binary string\n        prev = self._IV\n        for i in range(len(plainblocks)):\n            plainblock = plainblocks[i]\n            cipherblock = self._ECB.encrypt(strxor(plainblock, prev))\n            ciphertext += cipherblock\n            prev = cipherblock\n        return ciphertext\n\n    def decrypt(self, ciphertext):\n        cipherblocks = self._getBlocks(ciphertext)\n        plaintext = b''\n        prev = self._IV\n        for i in range(len(cipherblocks)):\n            cipherblock = cipherblocks[i]\n            plainblock = strxor(self._ECB.decrypt(cipherblock), prev)\n            plaintext += plainblock\n            prev = cipherblock\n        return plaintext\n\nx = base64.b64decode(open('Text/10.txt', 'r').read())\nkey = b'YELLOW SUBMARINE'\ncipher = CBC(AES.new(key, AES.MODE_ECB), chr(0) * 16) # IV 全 ascii 0!\ny = cipher.decrypt(x)\nprint(y)\nz = cipher.encrypt(y)\nif x != z:\n    raise Exception(x + b' != ' + z)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge11 - ECB, CBC Oracl\n\n寫一個產生random 16 bytes key的function，和一個自己產生random 16 bytes key然後加密文字的function\n\n```\nencryption_oracle(your-input)\n=> [MEANINGLESS JIBBER JABBER]\n```\n\n然後此function 在plaintext前後各加上 5-10 bytes，接下來寫一個function隨機使用ECB或CBC，然後我們必須去偵測此function用哪種mode!"}
{"cell_type":"code","execution_count":40,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Encrypting with CBC\nCBC\n"}],"source":"from Crypto.Cipher import AES\nfrom Crypto.Random import random\n\ndef encryption_oracle(s):\n    key = randbytes(16)\n    cipher = AES.new(key, AES.MODE_ECB)\n    if random.randint(0, 1) == 0:\n        print('Encrypting with ECB')\n    else:\n        print('Encrypting with CBC')\n        IV = randbytes(16)\n        cipher = CBC(cipher, IV)\n    s = randbytes(random.randint(5, 10)) + s + randbytes(random.randint(5, 10))\n    s = padPKCS7(s, 16)\n    return cipher.encrypt(s)\n\ndef detectMethod(encryption_oracle):\n    s = chr(0) * 47 # s = bytes([0] * 47) in python 3\n    t = encryption_oracle(s)\n    if t[16:32] == t[32:48]:\n        return 'ECB'\n    return 'CBC'\n\nprint(detectMethod(encryption_oracle))"}
{"cell_type":"markdown","metadata":{},"source":"## Breaking ECB\n### Challenge 12 - Byte-at-a-time ECB decryption (Simple)\n\n第二個經典的例子破解ECB，在input後加上unknown-string\n```\nUm9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\naGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\ndXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\nYnkK\n```\n先base64 去 deocde他，現在我們有以下型式的funtion\n\n```\nAES-128-ECB(your-string || unknown-string, random-key)\n```\n\n我們來破解這串unknown-string吧:\n\n1. 把相同的bytes一個個餵入 function  --- 一開始先 1 byte \"0\", 然後 \"00\", 然後 \"000\".... 藉此找出block的size(我們不知道encoded stuff多大)。\n\n2. 確認function是使用 ECB 加密\n\n3. 製造出一個少1 byte(相對於block size)的input (例如若 block size 是 8 bytes，input用 \"0000000\") 先想看看最後一個byte要放什麼->~~\n\n4. 建出一個look up table，涵蓋所有最後一個byted可能性的input， 例如 \"00000000\", \"00000001\", \"00000002\"\n\n5. 接下來比對步驟3產生的加密結果和look up table來找出unknown-string的第一個byte\n\n6. 重複找出下一個byte~"}
{"cell_type":"code","execution_count":42,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"144 144\n144 144\n144 144\n144 144\n144 144\n160 144\n"},{"data":{"text/plain":"16"},"execution_count":42,"metadata":{},"output_type":"execute_result"}],"source":"from Crypto.Cipher import AES\nimport base64\n\nencodedSuffix = b'''Um9sbGluJyBpbiBteSA1LjAKV2l0aCBteSByYWctdG9wIGRvd24gc28gbXkg\naGFpciBjYW4gYmxvdwpUaGUgZ2lybGllcyBvbiBzdGFuZGJ5IHdhdmluZyBq\ndXN0IHRvIHNheSBoaQpEaWQgeW91IHN0b3A/IE5vLCBJIGp1c3QgZHJvdmUg\nYnkK'''\nkey = None\n\ndef encryption_oracle(s):\n    global key\n    if key is None:\n        key = randbytes(16)\n    cipher = AES.new(key, AES.MODE_ECB)\n    s = padPKCS7(s + base64.b64decode(encodedSuffix), 16)\n    return cipher.encrypt(s)\n\ndef findBlockSize(encryption_oracle):\n    l = len(encryption_oracle(b'')) # 利用會padded的性質\n    i = 1\n    while True:\n        s = chr(0) * i\n        t = encryption_oracle(s)\n        print len(t), l\n        if len(t) != l:\n            return len(t) - l\n        i += 1\n\ndef confirmECB(encryption_oracle, blocksize):\n    s = randbytes(blocksize) * 2\n    t = encryption_oracle(s)\n    if t[0:blocksize] != t[blocksize:2*blocksize]:\n        raise Exception('Not using ECB')\n\ndef findNextByte(encryption_oracle, blocksize, knownBytes):\n    s = chr(0) * (blocksize - (len(knownBytes) % blocksize) - 1)\n    d = {}\n    for i in range(256):\n        t = encryption_oracle(s + knownBytes + chr(i))\n        d[t[0:len(s) + len(knownBytes) + 1]] = i # 建構一個dictionary，利用ECB 明文對照密文會固定的特性\n    t = encryption_oracle(s)\n    u = t[0:len(s) + len(knownBytes) + 1]\n    if u in d:\n        return d[u]\n    return None\n\nblocksize = findBlockSize(encryption_oracle)\nblocksize"}
{"cell_type":"code","execution_count":43,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Rollin' in my 5.0\nWith my rag-top down so my hair can blow\nThe girlies on standby waving just to say hi\nDid you stop? No, I just drove by\n\u0001\n"}],"source":"confirmECB(encryption_oracle, blocksize) #若不是將產生exception\ns = b''\nwhile True:\n    b = findNextByte(encryption_oracle, blocksize, s)\n    if b is None:\n        break\n    s += chr(b)\nprint(s)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 13 - ECB cut-and-paste\n### Parsing Cookie\n\n寫一個parse k=v的程式，例如\n```\nfoo=bar&baz=qux&zap=zazzle\n```\n\n產生似JSON的格式 \n```\n{\n  foo: 'bar',\n  baz: 'qux',\n  zap: 'zazzle'\n}\n```\n\n接下來寫一個可以encode user資訊的function，給他email將產生cookie\n\n```\nprofile_for(\"foo@bar.com\")\n\n{\n  email: 'foo@bar.com',\n  uid: 10,\n  role: 'user'\n}\n\nemail=foo@bar.com&uid=10&role=user\n```\n\nfunctiuon需處理metacharacters(& =)，否則user可以設``foo@bar.com&role=admin``。\n\n接下來寫兩個function\n\n1. 加密encode後的資料，並將資料給attacker\n2. 解密encode後的資料，並parse他\n\n用 profile_for() 的input 介面 (as an oracle to generate \"valid\" ciphertexts) 和 ciphertexts 來產生 ``role=admin``的 profile\n"}
{"cell_type":"code","execution_count":44,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[[u'email', u'foo@bar.commm'], [u'uid', u'10'], [u'role', u'admin']]\n"}],"source":"from Crypto.Cipher import AES\n\ndef encode_profile(profile):\n    s = b''\n    def sanitize(s):\n        return s.replace(b'&', b'').replace(b'=', b'')\n    for kv in profile:\n        sanitizedKV = [sanitize(x.encode('ascii')) for x in kv]\n        if s != b'':\n            s += b'&'\n        s += sanitizedKV[0] + b'=' + sanitizedKV[1]\n    return s\n\ndef profile_for(email):\n    profile = [\n        ['email', email],\n        ['uid', '10'],\n        ['role', 'user']\n        ]\n    return encode_profile(profile)\n\nkey = randbytes(16)\n\ndef encrypt_profile_for(email):\n    cipher = AES.new(key, AES.MODE_ECB)\n    encoded_profile = padPKCS7(profile_for(email), 16)\n    return cipher.encrypt(encoded_profile)\n\ndef unpadPKCS7(s):\n    i = s[-1]\n    return s[0:-ord(i)]\n\ndef decrypt_profile(s):\n    cipher = AES.new(key, AES.MODE_ECB)\n    decrypted_profile = unpadPKCS7(cipher.decrypt(s))\n    pairs = decrypted_profile.split(b'&')\n    profile = []\n    for p in pairs:\n        profile += [[x.decode('ascii') for x in p.split(b'=')]]\n    return profile\n\nemail1 = 'foo@bar.coadmin' + ('\\x0b' * 11) #直接cut and paste來取得admin的密文~~~\nx1 = encrypt_profile_for(email1)\nemail2 = 'foo@bar.commm'\nx2 = encrypt_profile_for(email2)\nx = x2[0:32] + x1[16:32]\ny = decrypt_profile(x)\nprint y"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 14 - Byte-at-a-time ECB decryption (Harder)\n\n多加一串 random 在前面\n\n```\nAES-128-ECB(random-prefix || attacker-controlled || target-bytes, random-key)\n```\n\n這個攻擊會變得比較困難~~"}
{"cell_type":"code","execution_count":45,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"176 176\n176 176\n176 176\n176 176\n176 176\n176 176\n176 176\n176 176\n176 176\n192 176\nRollin' in my 5.0\nWith my rag-top down so my hair can blow\nThe girlies on standby waving just to say hi\nDid you stop? No, I just drove by\n\u0001\n"}],"source":"from Crypto.Cipher import AES\nfrom Crypto.Random import random\nimport base64\n\nkey = None\nprefix = None\n\ndef encryption_oracle(s):\n    global key\n    global prefix\n    if key is None:\n        key = randbytes(16)\n    if prefix is None:\n        # TODO(phonchi): Extend to arbitrary sizes.\n        randcount = random.randint(16, 32)\n        prefix = randbytes(randcount)\n    cipher = AES.new(key, AES.MODE_ECB)\n    s = padPKCS7(prefix + s + base64.b64decode(encodedSuffix), 16)\n    return cipher.encrypt(s)\n\ndef getBlocks(s, blocksize):\n    return [s[i:i+blocksize] for i in range(0, len(s), blocksize)]\n\ndef findPrefixBlock(encryption_oracle, blocksize):\n    x1 = encryption_oracle(b'')\n    x2 = encryption_oracle(b'0')\n    blocks1 = getBlocks(x1, blocksize)\n    blocks2 = getBlocks(x2, blocksize)\n    for i in range(len(blocks1)):\n        if blocks1[i] != blocks2[i]:\n            return i\n\ndef findPrefixSizeModBlockSize(encryption_oracle, blocksize):\n    def has_equal_block(blocks):\n        for i in range(len(blocks) - 1):\n            if blocks[i] == blocks[i+1]:\n                return True\n        return False\n\n    for i in range(blocksize):\n        s = chr(0) * (2*blocksize + i)\n        t = encryption_oracle(s)\n        blocks = getBlocks(t, blocksize)\n        if has_equal_block(blocks):\n            return blocksize - i\n\n    raise Exception('Not using ECB')\n\ndef findPrefixSize(encryption_oracle, blocksize):\n    return blocksize*findPrefixBlock(encryption_oracle, blocksize) + findPrefixSizeModBlockSize(encryption_oracle, blocksize)\n\ndef findNextByte(encryption_oracle, blocksize, prefixsize, knownBytes):\n    k1 = blocksize - (prefixsize % blocksize)\n    k2 = blocksize - (len(knownBytes) % blocksize) - 1\n    k3 = prefixsize - (prefixsize % blocksize)\n    s = chr(0) * (k1 + k2)\n    d = {}\n    for i in range(256):\n        t = encryption_oracle(s + knownBytes + chr(i))\n        d[t[k3+k1:k3+k1+k2 + len(knownBytes) + 1]] = i\n    t = encryption_oracle(s)\n    u = t[k3+k1:k3+k1+k2 + len(knownBytes) + 1]\n    if u in d:\n        return d[u]\n    return None\n\nblocksize = findBlockSize(encryption_oracle)\nprefixsize = findPrefixSize(encryption_oracle, blocksize)\ns = b''\nwhile True:\n    b = findNextByte(encryption_oracle, blocksize, prefixsize, s)\n    if b is None:\n        break\n    s +=chr(b)\nprint(s)"}
{"cell_type":"markdown","metadata":{},"source":"### Padding Validation\n### Challenge 15 - PKCS#7 padding validation\n\n當padding不合法時請拋出異常!!"}
{"cell_type":"code","execution_count":46,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"'\\x00'"},"execution_count":46,"metadata":{},"output_type":"execute_result"}],"source":"s = b'ICE ICE BABY\\x04\\x04\\x04\\x04'\nchr(0)"}
{"cell_type":"code","execution_count":47,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"ICE ICE BABY\nvalue error 1\nvalue error 2\n"}],"source":"def unpadPKCS7(s):\n    i = s[-1]\n    if (i == chr(0)) or (s[-ord(i):] != i * ord(i)):\n        raise ValueError('bad padding')\n    return s[0:-ord(i)]\n\n\nprint(unpadPKCS7(b'ICE ICE BABY\\x04\\x04\\x04\\x04'))\ntry:\n    unpadPKCS7(b'ICE ICE BABY\\x05\\x05\\x05\\x05')\n    raise Exception('passes unexpectedly')\nexcept ValueError:\n    print \"value error 1\"\ntry:\n    unpadPKCS7(b'ICE ICE BABY\\x01\\x02\\x03\\x04')\n    raise Exception('passes unexpectedly')\nexcept ValueError:\n    print \"value error 2\""}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 16 - CBC bitflipping attacks\n\n產生一把隨機的 AES key.\n\n用前面的 padding 和 CBC來寫兩個 function\n\n- 第一個 function 可以輸入任意一字串然後前面附加\n```\n\"comment1=cooking%20MCs;userdata=\"\n```\n後面附加\n```\n\";comment2=%20like%20a%20pound%20of%20bacon\"\n```\nfunction 必須處理 \";\" and \"=\" 字元， 且要pad 到16-byte AES 位元長 然後用該 random AES key加密\n\n\n- 第二個function 去 decrypt 字串然後找看看 \";admin=true;\" 有沒有在裡面，並回傳 True 或 False\n\n用 crypto性質來破解，而不要直接從 user input 下手(第一個function 要判斷合法 input)，也就是說在不知道key的情況下來改變我們想要的ciphertext。\n\n> CBC mode的性質為在ciphertext block的 1-bit error會:\n> 1. 完全打亂該error存在的block \n> 2. 產生相同的 1-bit error 在下一個 ciphertext block."}
{"cell_type":"code","execution_count":48,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"from Crypto.Cipher import AES\n\nx = \"\"\nkey = randbytes(16)\niv = randbytes(16)\n\ndef encryptParams(userdata):\n    userdata = userdata.replace(';', '%3B').replace('=', '%3D')\n    x1 = b'comment1=cooking%20MCs;userdata='\n    x2 = b';comment2=%20like%20a%20pound%20of%20bacon'\n    params = x1 + userdata.encode('ascii') + x2\n    cipher = CBC(AES.new(key, AES.MODE_ECB), iv)\n    return cipher.encrypt(padPKCS7(params, 16))\n\ndef decryptParamsAndCheckAdmin(encryptedParams):\n    cipher = CBC(AES.new(key, AES.MODE_ECB), iv)\n    paddedParams = cipher.decrypt(encryptedParams)\n    params = unpadPKCS7(paddedParams)\n    print params\n    return params.find(b';admin=true;') != -1\nencryptParams('XXXXXXXXXXXXXXXX:admin<true:XXXX')[1], len(encryptParams('XXXXXXXXXXXXXXXX:admin<true:XXXX'))\nx = list(encryptParams('XXXXXXXXXXXXXXXX:admin<true:XXXX'))"}
{"cell_type":"code","execution_count":49,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"\"\\x97\\x98\\xf4+\\xe8Y5\\xa5 g\\xff\\x9b\\xdd\\xbb\\x04e_0p\\xc5\\x17'\\xcfmR\\xc2\\xd3\\x86\\xc7\\x145\\x1c\\xbe\\xf0\\x9d\\x8b\\xda-\\x17\\x01\\xf3\\xab\\x97dL%C\\x121~U\\x08\\t|\\x9c\\x12\\xf0='\\x92c\\x0f\\xa9e\\xae\\x8a$CH\\x88\\xde\\x9e\\xa4j#\\xc4He+Za\\xf6\\xa8\\xcf\\xf6\\xd45{\\xc0\\x9f/,\\xfa\\xc1J\\xbc\\xfb\\xe6\\xbb?\\x8f\\xb4\\xe5n\\x99\\xfe\\xd6\\x86\\xcf-c\\xa8\""},"execution_count":49,"metadata":{},"output_type":"execute_result"}],"source":"x[32] = strxor_c(x[32], 1)\nx[38] = strxor_c(x[38], 1)\nx[43] = strxor_c(x[43], 1)\n\"\".join(x)"}
{"cell_type":"code","execution_count":50,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"comment1=cooking%20MCs;userdata=�5\u0011��\u0002ZD�۫�h\u0007s;admin=true;XXXX;comment2=%20like%20a%20pound%20of%20bacon\nTrue\n"}],"source":"print decryptParamsAndCheckAdmin(\"\".join(x))"}
{"cell_type":"markdown","metadata":{},"source":"# Set 3\n### Challenge 17 - CBC Padding Oracle\n\n利用padding oracl的 side channel(對或錯來破解)\n\n第一個function由以下的字串隨機選一個\n```\nMDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=\nMDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=\nMDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==\nMDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==\nMDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl\nMDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==\nMDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==\nMDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=\nMDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=\nMDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93\n```\n\n隨機產生一個AES key存下他，將選出的string pad到16 byte AES block，用CBC加密他，並回傳ciphertext和 IV。\n\n第二個function為server的，接收ciphertext，解密他並檢察padding，來傳回padding是否valid (這是server檢查cookie常用的方式)。\n\n\n注意 byte 01h 是 valid padding，且發生機率為 1/256 在解密偽造的ciphertext時( \"randomized\" plaintexts情況下)\n\n02h 02h 是 valid padding，但可能出現機率很小...\n\n所以當我們偽造出valid padding...\n"}
{"cell_type":"code","execution_count":65,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"'\\x05'"},"execution_count":65,"metadata":{},"output_type":"execute_result"}],"source":"from Crypto.Util.strxor import strxor_c\nfrom Crypto.Util.strxor import strxor\nchr(5)"}
{"cell_type":"code","execution_count":66,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"000008ollin' in my five point oh\n"}],"source":"from Crypto.Cipher import AES\nfrom Crypto.Random import random\nimport base64\nfrom Crypto.Util.strxor import strxor_c\n\nstrings = [\n    b'MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=',\n    b'MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYXJlIHB1bXBpbic=',\n    b'MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2luZw==',\n    b'MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==',\n    b'MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYmxl',\n    b'MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==',\n    b'MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==',\n    b'MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=',\n    b'MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=',\n    b'MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93'\n]\n\nkey = randbytes(16)\n\ndef ciphertext_oracle():\n    s = base64.b64decode(random.choice(strings))\n    iv = randbytes(16)\n    cipher = CBC(AES.new(key, AES.MODE_ECB), iv)\n    return (iv, cipher.encrypt(padPKCS7(s, 16)))\n\ndef padding_oracle(iv, s):\n    cipher = CBC(AES.new(key, AES.MODE_ECB), iv)\n    paddedT = cipher.decrypt(s)\n    try:\n        t = unpadPKCS7(paddedT)\n    except ValueError:\n        return False\n    return True\n\ndef decipher_last_block_previous_byte(iv, s, padding_oracle, knownI, knownP):\n    k = len(knownI) + 1\n    prefix = randbytes(16 - k)\n    for i in range(256):\n        c1 = s[-32:-16] if len(s) > 16 else iv\n        if k == 16:\n            c1p = chr(i) + \"\".join([strxor_c(ch , k) for ch in knownI])\n        else:\n            c1p = prefix + chr(i) + \"\".join([strxor_c(ch , k) for ch in knownI])            \n        sp = s[:-32] + c1p + s[-16:]\n        if padding_oracle(iv, sp):\n            iPrev = i ^ k\n            pPrev = strxor_c(c1[-k], iPrev)\n            return chr(iPrev) + knownI , pPrev + knownP\n    raise Exception('unexpected')\n\ndef decipher_last_block(iv, s, padding_oracle):\n    knownI = b''\n    knownP = b''\n    for i in range(16):\n        (knownI, knownP) = decipher_last_block_previous_byte(iv, s, padding_oracle, knownI, knownP)\n    return knownP\n\ndef decipher(iv, s, padding_oracle):\n    knownP = b''\n    for i in range(len(s) / 16):\n        st = s if i == 0 else s[:-i * 16]\n        knownP = decipher_last_block(iv, st, padding_oracle) + knownP\n    return unpadPKCS7(knownP)\n\n(iv, s) = ciphertext_oracle()\nprint decipher(iv, s, padding_oracle)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 18 - CTR Mode\n\n```\nkey=YELLOW SUBMARINE\nnonce=0\nformat=64 bit unsigned little endian nonce,64 bit little endian block count (byte count / 16)\n```\n\n![](https://i.imgur.com/W3naT4Y.png)\n\n\nCTR Mode不需padding，他只是以下列方式循序進行加密\n```\nkeystream = AES(\"YELLOW SUBMARINE\",\n                \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")\nkeystream = AES(\"YELLOW SUBMARINE\",\n                \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\")                \n```\n"}
{"cell_type":"code","execution_count":67,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Yo, VIP Let's kick it Ice, Ice, baby Ice, Ice, baby \n"}],"source":"import base64\nimport struct\nfrom Crypto.Cipher import AES\nfrom Crypto.Util.strxor import strxor\n\nclass CTR:\n    def __init__(self, ECB, nonce):\n        self._ECB = ECB\n        self._nonce = nonce\n        self._blocksize = 16\n        self._keybytes = b''\n        self._blockcount = 0\n\n    def encrypt(self, plaintext):\n        # Work around strxor() not handling zero-length strings\n        # gracefully.\n        if len(plaintext) == 0:\n            return b''\n\n        keystream = self._keybytes\n        while len(keystream) < len(plaintext):\n            keyblock = self._ECB.encrypt(struct.pack('<QQ', self._nonce, self._blockcount))\n            keystream += keyblock\n            self._blockcount += 1\n\n        if len(keystream) > len(plaintext):\n            self._keybytes = keystream[len(plaintext):]\n            keystream = keystream[:len(plaintext)]\n\n        return strxor(plaintext, keystream)\n\n    def decrypt(self, ciphertext):\n        return self.encrypt(ciphertext)\n\nx = base64.b64decode('L77na/nrFsKvynd6HzOoG7GHTLXsTVu9qvY/2syLXzhPweyyMTJULu/6/kXX0KSvoOLSFQ==')\n\nkey = b'YELLOW SUBMARINE'\ncipher1 = CTR(AES.new(key, AES.MODE_ECB), 0)\ny = cipher1.decrypt(x)\nprint(y)\ncipher2 = CTR(AES.new(key, AES.MODE_ECB), 0)\nz = cipher2.encrypt(y)\nif x != z:\n    raise Exception(x + b' != ' + z)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 19 - Break fixed-nonce CTR mode using substitutions\n\n若不randomized nonce的話，利用以下算式可破CTR\n\n```\nCIPHERTEXT-BYTE XOR PLAINTEXT-BYTE = KEYSTREAM-BYTE\n```\n\n這邊用到頻率分析中的triagram\n"}
{"cell_type":"code","execution_count":68,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"smc-blob::caf9820e-75fc-4527-afd0-7e63f4aac666"},"execution_count":68,"metadata":{},"output_type":"execute_result"}],"source":"from Crypto.Cipher import AES\nfrom Crypto.Util.strxor import strxor\nimport base64\nimport binascii\nimport itertools\n\nstrings = [\n    b'SSBoYXZlIG1ldCB0aGVtIGF0IGNsb3NlIG9mIGRheQ==',\n    b'Q29taW5nIHdpdGggdml2aWQgZmFjZXM=',\n    b'RnJvbSBjb3VudGVyIG9yIGRlc2sgYW1vbmcgZ3JleQ==',\n    b'RWlnaHRlZW50aC1jZW50dXJ5IGhvdXNlcy4=',\n    b'SSBoYXZlIHBhc3NlZCB3aXRoIGEgbm9kIG9mIHRoZSBoZWFk',\n    b'T3IgcG9saXRlIG1lYW5pbmdsZXNzIHdvcmRzLA==',\n    b'T3IgaGF2ZSBsaW5nZXJlZCBhd2hpbGUgYW5kIHNhaWQ=',\n    b'UG9saXRlIG1lYW5pbmdsZXNzIHdvcmRzLA==',\n    b'QW5kIHRob3VnaHQgYmVmb3JlIEkgaGFkIGRvbmU=',\n    b'T2YgYSBtb2NraW5nIHRhbGUgb3IgYSBnaWJl',\n    b'VG8gcGxlYXNlIGEgY29tcGFuaW9u',\n    b'QXJvdW5kIHRoZSBmaXJlIGF0IHRoZSBjbHViLA==',\n    b'QmVpbmcgY2VydGFpbiB0aGF0IHRoZXkgYW5kIEk=',\n    b'QnV0IGxpdmVkIHdoZXJlIG1vdGxleSBpcyB3b3JuOg==',\n    b'QWxsIGNoYW5nZWQsIGNoYW5nZWQgdXR0ZXJseTo=',\n    b'QSB0ZXJyaWJsZSBiZWF1dHkgaXMgYm9ybi4=',\n    b'VGhhdCB3b21hbidzIGRheXMgd2VyZSBzcGVudA==',\n    b'SW4gaWdub3JhbnQgZ29vZCB3aWxsLA==',\n    b'SGVyIG5pZ2h0cyBpbiBhcmd1bWVudA==',\n    b'VW50aWwgaGVyIHZvaWNlIGdyZXcgc2hyaWxsLg==',\n    b'V2hhdCB2b2ljZSBtb3JlIHN3ZWV0IHRoYW4gaGVycw==',\n    b'V2hlbiB5b3VuZyBhbmQgYmVhdXRpZnVsLA==',\n    b'U2hlIHJvZGUgdG8gaGFycmllcnM/',\n    b'VGhpcyBtYW4gaGFkIGtlcHQgYSBzY2hvb2w=',\n    b'QW5kIHJvZGUgb3VyIHdpbmdlZCBob3JzZS4=',\n    b'VGhpcyBvdGhlciBoaXMgaGVscGVyIGFuZCBmcmllbmQ=',\n    b'V2FzIGNvbWluZyBpbnRvIGhpcyBmb3JjZTs=',\n    b'SGUgbWlnaHQgaGF2ZSB3b24gZmFtZSBpbiB0aGUgZW5kLA==',\n    b'U28gc2Vuc2l0aXZlIGhpcyBuYXR1cmUgc2VlbWVkLA==',\n    b'U28gZGFyaW5nIGFuZCBzd2VldCBoaXMgdGhvdWdodC4=',\n    b'VGhpcyBvdGhlciBtYW4gSSBoYWQgZHJlYW1lZA==',\n    b'QSBkcnVua2VuLCB2YWluLWdsb3Jpb3VzIGxvdXQu',\n    b'SGUgaGFkIGRvbmUgbW9zdCBiaXR0ZXIgd3Jvbmc=',\n    b'VG8gc29tZSB3aG8gYXJlIG5lYXIgbXkgaGVhcnQs',\n    b'WWV0IEkgbnVtYmVyIGhpbSBpbiB0aGUgc29uZzs=',\n    b'SGUsIHRvbywgaGFzIHJlc2lnbmVkIGhpcyBwYXJ0',\n    b'SW4gdGhlIGNhc3VhbCBjb21lZHk7',\n    b'SGUsIHRvbywgaGFzIGJlZW4gY2hhbmdlZCBpbiBoaXMgdHVybiw=',\n    b'VHJhbnNmb3JtZWQgdXR0ZXJseTo=',\n    b'QSB0ZXJyaWJsZSBiZWF1dHkgaXMgYm9ybi4=',\n]\n\n# Generated randomly.\nkey = b'\\xa3\\xc9\\xe7\\xedmZU\\x1e\\xac\\x15\\xe2\\xaf\\xb4$\\xa9{'\n\ndef encryptString(s):\n    cipher = CTR(AES.new(key, AES.MODE_ECB), 0)\n    return cipher.encrypt(s)\n\nencryptedStrings = [encryptString(base64.b64decode(s)) for s in strings]\n\ndef getPrintableKeyChar(encryptedStrings, i):\n    for j in range(256):\n        decrypted = [strxor_c(x[i], j) for x in encryptedStrings]\n        if all([x in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,' for x in decrypted]):\n            yield j # 產生iterator\n\ndef extendKey(k, ciphertext, guess):\n    return k + \"\".join([ strxor(guess[i], ciphertext[len(k) + i]) for i in range(len(guess))])\n\nks = [getPrintableKeyChar(encryptedStrings, i) for i in range(10)]\nks"}
{"cell_type":"code","execution_count":69,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"'S\\xe9\\x95e\\xc8yj\\x91\\xb2\\x82'"},"execution_count":69,"metadata":{},"output_type":"execute_result"}],"source":"# k = \"\".join(list(itertools.islice(itertools.product(*ks), 1))[0])\nk = \"\".join([chr(strk) for strk in list(itertools.islice(itertools.product(*ks), 1))[0]])\nk"}
{"cell_type":"code","execution_count":70,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"I have met them at close of day\nComing with vivid faces\nFrom counter or desk among grey\nEighteenth-century houses.\nI have passed with a nod of the head\nOr polite meaningless words,\nOr have lingered awhile and said\nPolite meaningless words,\nAnd thought before I had done\nOf a mocking tale or a gibe\nTo please a companion\nAround the fire at the club,\nBeing certain that they and I\nBut lived where motley is worn:\nAll changed, changed utterly:\nA terrible beauty is born.\nThat woman's days were spent\nIn ignorant good will,\nHer nights in argument\nUntil her voice grew shrill.\nWhat voice more sweet than hers\nWhen young and beautiful,\nShe rode to harriers?\nThis man had kept a school\nAnd rode our winged horse.\nThis other his helper and friend\nWas coming into his force;\nHe might have won fame in the end,\nSo sensitive his nature seemed,\nSo daring and sweet his thought.\nThis other man I had dreamed\nA drunken, vain-glorious lout.\nHe had done most bitter wrong\nTo some who are near my heart,\nYet I number him in the song;\nHe, too, has resigned his part\nIn the casual comedy;\nHe, too, has been changed in his turn,\nTransformed utterly:\nA terrible beauty is born.\n"}],"source":"k = extendKey(k, encryptedStrings[1], b'h ')\nk = extendKey(k, encryptedStrings[3], b'entury ')\nk = extendKey(k, encryptedStrings[5], b'ss ')\nk = extendKey(k, encryptedStrings[3], b'se')\nk = extendKey(k, encryptedStrings[5], b'rds')\nk = extendKey(k, encryptedStrings[0], b' ')\nk = extendKey(k, encryptedStrings[29], b'ght')\nk = extendKey(k, encryptedStrings[4], b' ')\nk = extendKey(k, encryptedStrings[27], b'd')\nk = extendKey(k, encryptedStrings[4], b'ead')\nk = extendKey(k, encryptedStrings[37], b'n,')\nkl = len(k)\ndecrypted = [strxor(x[:kl], k[:len(x)]) + x[kl:] for x in encryptedStrings]\nfor i in range(len(decrypted)):\n    if decrypted[i] != base64.b64decode(strings[i]):\n        raise Exception('Invalid decryption')\n    print(decrypted[i])"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 20 - Break fixed-nonce CTR statistically\n\n用跟破repeating XOR一樣的方法"}
{"cell_type":"code","execution_count":71,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"},"execution_count":71,"metadata":{},"output_type":"execute_result"}],"source":"from Crypto.Util.strxor import strxor\nimport base64\nimport itertools\n\nstrings = [base64.b64decode(x) for x in open('Text/20.txt', 'r').read().split('\\n')]\nstrings = strings[:-1]\n\nencryptedStrings = [encryptString(s) for s in strings]\ntransposedStrings = list(zip(*encryptedStrings))\nkey = [chr(breakSingleByteXOR(\"\".join(x))[0]) for x in transposedStrings]\n\"\".join(key)"}
{"cell_type":"code","execution_count":72,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'"},"execution_count":72,"metadata":{},"output_type":"execute_result"}],"source":"def breakSameKey(strings):\n    transposedStrings = list(zip(*strings))\n    key = [chr(breakSingleByteXOR(\"\".join(x))[0]) for x in transposedStrings]\n    return \"\".join(key)\nkey = breakSameKey(encryptedStrings)\nkey"}
{"cell_type":"code","execution_count":73,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"ename":"Exception","evalue":"Invalid decryption","output_type":"error","traceback":["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m","\u001b[1;31mException\u001b[0m                                 Traceback (most recent call last)","\u001b[1;32m<ipython-input-73-c3cb32cf469e>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m     23\u001b[0m     \u001b[0mdecrypted\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mstrxor\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ms\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m:\u001b[0m\u001b[0mkl\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mkey\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m:\u001b[0m\u001b[0mlen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0ms\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m+\u001b[0m \u001b[0ms\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mkl\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     24\u001b[0m     \u001b[1;32mif\u001b[0m \u001b[0mdecrypted\u001b[0m \u001b[1;33m!=\u001b[0m \u001b[0mstrings\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mi\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 25\u001b[1;33m         \u001b[1;32mraise\u001b[0m \u001b[0mException\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Invalid decryption'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     26\u001b[0m     \u001b[1;32mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mi\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdecrypted\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;31mException\u001b[0m: Invalid decryption"]}],"source":"key = strxor_c(encryptedStrings[0][0] , ord('I')) + key[1:]\nkey = extendKey(key, encryptedStrings[13], b'-M ')\nkey = extendKey(key, encryptedStrings[16], b'ime ')\nkey = extendKey(key, encryptedStrings[1], b'htnin')\nkey = extendKey(key, encryptedStrings[2], b'y')\nkey = extendKey(key, encryptedStrings[6], b'ty')\nkey = extendKey(key, encryptedStrings[0], b'i')\nkey = extendKey(key, encryptedStrings[3], b'n up')\nkey = extendKey(key, encryptedStrings[7], b'ession')\nkey = extendKey(key, encryptedStrings[4], b'or ')\nkey = extendKey(key, encryptedStrings[1], b'ghtenin')\nkey = extendKey(key, encryptedStrings[17], b'able')\nkey = extendKey(key, encryptedStrings[11], b'st')\nkey = extendKey(key, encryptedStrings[2], b'k')\nkey = extendKey(key, encryptedStrings[12], b'nk')\nkey = extendKey(key, encryptedStrings[26], b've ')\nkey = extendKey(key, encryptedStrings[41], b'll')\nkey = extendKey(key, encryptedStrings[21], b'ace')\nkey = extendKey(key, encryptedStrings[26], b'hole scenery')\nkl = len(key)\nfor i in range(len(encryptedStrings)):\n    s = encryptedStrings[i]\n    decrypted = strxor(s[:kl], key[:len(s)]) + s[kl:]\n    if decrypted != strings[i]:\n        raise Exception('Invalid decryption')\n    print(i, decrypted)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 21 - MT19937\n\nMersenne Twister RNG\n\nR、Python、Ruby、IDL、Free Pascal、PHP、Maple、Matlab、GMP 預設的rand()"}
{"cell_type":"code","execution_count":74,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"class MT19937:\n    def __init__(self, seed):\n        self._index = 0\n        self._MT = [0] * 624\n        self._MT[0] = seed & 0xffffffff\n        for i in range(1, 624):\n            self._MT[i] = ((0x6c078965 * (self._MT[i-1] ^ (self._MT[i-1] >> 30))) + i) & 0xffffffff\n\n    def uint32(self):\n        if self._index == 0:\n            self.generate_numbers()\n\n        y = self._MT[self._index]\n        y ^= (y >> 11)\n        y ^= ((y << 7) & 0x9d2c5680)\n        y ^= ((y << 15) & 0xefc60000)\n        y ^= (y >> 18)\n\n        self._index = (self._index + 1) % 624\n        return y\n\n    def generate_numbers(self):\n        for i in range(624):\n            y = (self._MT[i] & 0x80000000) + (self._MT[(i+1) % 624] & 0x7fffffff)\n            self._MT[i] = self._MT[(i + 397) % 624] ^ (y >> 1)\n            if y % 2 != 0:\n                self._MT[i] ^= 0x9908b0df\n\n\nexpectedNumbers = [int(x) for x in open('Text/21.txt', 'r').read().split('\\n')[:-1]]\nseed = 5489\nx = MT19937(seed)\nfor i in range(1000):\n    a = x.uint32()\n    if a != expectedNumbers[i]:\n        raise Exception(str(i) + ' ' + a + ' != ' + expectedNumbers[i])"}
{"cell_type":"code","execution_count":75,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"27"},"execution_count":75,"metadata":{},"output_type":"execute_result"}],"source":"import random\nrandom.seed(5489)\nrandom.randint(0, 2^32)"}
{"cell_type":"markdown","metadata":{},"source":"### challenge 22 - Crack an MT19937 seed"}
{"cell_type":"code","execution_count":76,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"1467638123\n1837720241\n1467638123\n"}],"source":"from Crypto.Random import random\nimport time\n\nt = int(time.time())\nt += random.randint(40, 1000)\nseed = int(t)\nprint(seed)\nrng = MT19937(seed)\nx = rng.uint32()\nprint(x)\n\nt += random.randint(40, 1000)\nfor i in range(2000):\n    k = t - i\n    rng2 = MT19937(k)\n    y = rng2.uint32()\n    if x == y:\n        print(k)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 23 - Clone an MT19937 RNG from its output"}
{"cell_type":"code","execution_count":77,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"from Crypto.Random import random\n\ndef getMSB(x, n):\n    if n < 0:\n        return 0\n    return (x >> (31 - n)) & 1\n\ndef setMSB(x, n, b):\n    return x | (b << (31 - n))\n\ndef undoRightShiftXor(y, s):\n    z = 0\n    for i in range(32):\n        z = setMSB(z, i, getMSB(y, i) ^ getMSB(z, i - s))\n    return z\n\ndef getLSB(x, n):\n    if n < 0:\n        return 0\n    return (x >> n) & 1\n\ndef setLSB(x, n, b):\n    return x | (b << n)\n\ndef undoLeftShiftXorAnd(y, s, k):\n    z = 0\n    for i in range(32):\n       z = setLSB(z, i, getLSB(y, i) ^ (getLSB(z, i - s) & getLSB(k, i)))\n    return z\n\ndef untemper(y):\n    y = undoRightShiftXor(y, 18)\n    y = undoLeftShiftXorAnd(y, 15, 0xefc60000)\n    y = undoLeftShiftXorAnd(y, 7, 0x9d2c5680)\n    y = undoRightShiftXor(y, 11)\n    return y\n\nseed = random.getrandbits(32)\nrng = MT19937(seed)\nMT = [0] * 624\nfor i in range(624):\n    MT[i] = untemper(rng.uint32())\nrng2 = MT19937(0)\nrng2._MT = MT\n\nfor i in range(1000):\n    a = rng.uint32()\n    b = rng2.uint32()\n    if a != b:\n        raise Exception(str(i) + ' ' + str(a) + ' != ' + str(b))"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 24 - Create the MT19937 stream cipher"}
{"cell_type":"code","execution_count":78,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"(48554L, 48554)\n('\\xb5\\xfb\\x01\\xa3`\\x1e\\xf1\\xd7\\x80%\\x93\\xf9\\xb4\\xa4>^\\xca\\x81\\x89', True)\n"}],"source":"from Crypto.Util.strxor import strxor\nfrom Crypto.Random import random\nimport struct\nimport time\n\nclass MT19937Cipher:\n    def __init__(self, key):\n        self._rng = MT19937(key & 0xffff)\n        self._keybytes = b''\n\n    def encrypt(self, plaintext):\n        # Work around strxor() not handling zero-length strings\n        # gracefully.\n        if len(plaintext) == 0:\n            return b''\n\n        keystream = self._keybytes\n        while len(keystream) < len(plaintext):\n            keyblock = struct.pack('<L', self._rng.uint32())\n            keystream += keyblock\n\n        if len(keystream) > len(plaintext):\n            self._keybytes = keystream[len(plaintext):]\n            keystream = keystream[:len(plaintext)]\n\n        return strxor(plaintext, keystream)\n\n    def decrypt(self, ciphertext):\n        return self.encrypt(ciphertext)\n\nkey = random.getrandbits(16)\n\ndef encryption_oracle(plaintext):\n    prefix = randbytes(random.randint(4, 20))\n    cipher = MT19937Cipher(key)\n    return cipher.encrypt(prefix + plaintext)\n\ndef recover_key(encryption_oracle):\n    plaintext = b'0' * 14\n    ciphertext = encryption_oracle(plaintext)\n    prefix_len = len(ciphertext) - len(plaintext)\n    for i in range(2**16-1):\n        cipher = MT19937Cipher(i)\n        s = cipher.encrypt(b'0' * len(ciphertext))\n        if ciphertext[prefix_len:] == s[prefix_len:]:\n            return i\n    raise Exception('unexpected')\n\nprint(key, recover_key(encryption_oracle))\n\ndef token_oracle():\n    seed = int(time.time())\n    cipher = MT19937Cipher(seed)\n    plaintext = b'0' * random.randint(4, 20)\n    return cipher.encrypt(plaintext)\n\ndef is_token_for_current_time(token):\n    seed = int(time.time())\n    cipher = MT19937Cipher(seed)\n    plaintext = b'0' * len(token)\n    return cipher.encrypt(plaintext) == token\n\nx = token_oracle()\nprint(x, is_token_for_current_time(x))"}
{"cell_type":"markdown","metadata":{},"source":"# Set4\n## Stream Cipher\n### Challenge 25 - Break \"random access read/write\" AES CTR"}
{"cell_type":"code","execution_count":79,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"I'm back and I'm ringin' the bell \nA rockin' on the mike while the fly girls yell \nIn ecstasy in the back of me \nWell that's my DJ Deshay cuttin' all them Z's \nHittin' hard and the girlies goin' crazy \nVanilla's on the mike, man I'm not lazy. \n\nI'm lettin' my drug kick in \nIt controls my mouth and I begin \nTo just let it flow, let my concepts go \nMy posse's to the side yellin', Go Vanilla Go! \n\nSmooth 'cause that's the way I will be \nAnd if you don't give a damn, then \nWhy you starin' at me \nSo get off 'cause I control the stage \nThere's no dissin' allowed \nI'm in my own phase \nThe girlies sa y they love me and that is ok \nAnd I can dance better than any kid n' play \n\nStage 2 -- Yea the one ya' wanna listen to \nIt's off my head so let the beat play through \nSo I can funk it up and make it sound good \n1-2-3 Yo -- Knock on some wood \nFor good luck, I like my rhymes atrocious \nSupercalafragilisticexpialidocious \nI'm an effect and that you can bet \nI can take a fly girl and make her wet. \n\nI'm like Samson -- Samson to Delilah \nThere's no denyin', You can try to hang \nBut you'll keep tryin' to get my style \nOver and over, practice makes perfect \nBut not if you're a loafer. \n\nYou'll get nowhere, no place, no time, no girls \nSoon -- Oh my God, homebody, you probably eat \nSpaghetti with a spoon! Come on and say it! \n\nVIP. Vanilla Ice yep, yep, I'm comin' hard like a rhino \nIntoxicating so you stagger like a wino \nSo punks stop trying and girl stop cryin' \nVanilla Ice is sellin' and you people are buyin' \n'Cause why the freaks are jockin' like Crazy Glue \nMovin' and groovin' trying to sing along \nAll through the ghetto groovin' this here song \nNow you're amazed by the VIP posse. \n\nSteppin' so hard like a German Nazi \nStartled by the bases hittin' ground \nThere's no trippin' on mine, I'm just gettin' down \nSparkamatic, I'm hangin' tight like a fanatic \nYou trapped me once and I thought that \nYou might have it \nSo step down and lend me your ear \n'89 in my time! You, '90 is my year. \n\nYou're weakenin' fast, YO! and I can tell it \nYour body's gettin' hot, so, so I can smell it \nSo don't be mad and don't be sad \n'Cause the lyrics belong to ICE, You can call me Dad \nYou're pitchin' a fit, so step back and endure \nLet the witch doctor, Ice, do the dance to cure \nSo come up close and don't be square \nYou wanna battle me -- Anytime, anywhere \n\nYou thought that I was weak, Boy, you're dead wrong \nSo come on, everybody and sing this song \n\nSay -- Play that funky music Say, go white boy, go white boy go \nplay that funky music Go white boy, go white boy, go \nLay down and boogie and play that funky music till you die. \n\nPlay that funky music Come on, Come on, let me hear \nPlay that funky music white boy you say it, say it \nPlay that funky music A little louder now \nPlay that funky music, white boy Come on, Come on, Come on \nPlay that funky music \n\u0004\u0004\u0004\u0004\n"}],"source":"from Crypto.Cipher import AES\nfrom Crypto.Random import random\nimport base64\nimport struct\n\nkey = randbytes(16)\nnonce = random.getrandbits(64)\n\ndef ciphertext_oracle():\n    ecb_ciphertext = base64.b64decode(open('Text/25.txt', 'r').read())\n    ecb_key = b'YELLOW SUBMARINE'\n    ecb_cipher = AES.new(ecb_key, AES.MODE_ECB)\n    plaintext = ecb_cipher.decrypt(ecb_ciphertext)\n    cipher = CTR(AES.new(key, AES.MODE_ECB), nonce)\n    return cipher.encrypt(plaintext)\n\ndef edit(ciphertext, offset, newtext):\n    cipher = CTR(AES.new(key, AES.MODE_ECB), nonce)\n    cipher.encrypt(b'\\x00' * offset)\n    return ciphertext[0:offset] + cipher.encrypt(newtext)\n\nciphertext = ciphertext_oracle()\nplaintext = edit(ciphertext, 0, ciphertext)\nprint(plaintext)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 26 - CTR bitflipping"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"from Crypto.Cipher import AES\nfrom Crypto.Random import random\n\n\nkey = randbytes(16)\nnonce = random.getrandbits(64)\n\ndef encryptParams(userdata):\n    userdata = userdata.replace(';', '%3B').replace('=', '%3D')\n    x1 = b'comment1=cooking%20MCs;userdata='\n    x2 = b';comment2=%20like%20a%20pound%20of%20bacon'\n    params = x1 + userdata.encode('ascii') + x2\n    cipher = CTR(AES.new(key, AES.MODE_ECB), nonce)\n    return cipher.encrypt(padPKCS7(params, 16))\n\ndef decryptParamsAndCheckAdmin(encryptedParams):\n    cipher = CTR(AES.new(key, AES.MODE_ECB), nonce)\n    paddedParams = cipher.decrypt(encryptedParams)\n    params = unpadPKCS7(paddedParams)\n    return params.find(b';admin=true;') != -1\n\nx = list(encryptParams(':admin<true:'))\nx[32] = strxor_c(x[32], 1)\nx[38] = strxor_c(x[38], 1)\nx[43] = strxor_c(x[43], 1)\n\nprint(decryptParamsAndCheckAdmin(\"\".join(x)))\n#x[32] ^= 1\n#x[38] ^= 1\n#x[43] ^= 1\n#print(decryptParamsAndCheckAdmin(bytes(x)))"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"### Challenge 27 - Recover the key from CBC with IV=Key\n\n為了省頻寬用 key 和 IV 相同是不安全的, Attacker 可以修改 ciphertext 來得到Key~"}
{"cell_type":"code","execution_count":80,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"!P��\u0007?ma�,��H&�\u0002\n"}],"source":"from Crypto.Cipher import AES\n\nkey = randbytes(16)\n\ndef encryptParams(userdata):\n    userdata = userdata.replace(';', '%3B').replace('=', '%3D')\n    x1 = b'comment1=cooking%20MCs;userdata='\n    x2 = b';comment2=%20like%20a%20pound%20of%20bacon'\n    params = x1 + userdata.encode('ascii') + x2\n    cipher = CBC(AES.new(key, AES.MODE_ECB), key)\n    return cipher.encrypt(padPKCS7(params, 16))\n\ndef decryptParamsAndCheckAdmin(encryptedParams):\n    cipher = CBC(AES.new(key, AES.MODE_ECB), key)\n    paddedParams = cipher.decrypt(encryptedParams)\n    params = unpadPKCS7(paddedParams)\n    if any([x > 127 for x in params]):\n        raise ValueError(params)\n    return params.find(b';admin=true;') != -1\n\nc = encryptParams('')\nc = c[0:16] + (b'\\x00' * 16) + c[0:16] + c[48:]\ntry:\n    decryptParamsAndCheckAdmin(c)\n    raise Exception('unexpected')\nexcept ValueError as e:\n    text = e.args[0]\n    extracted_key = \"\".join([strxor(text[i], text[32 + i]) for i in range(16)])\n    print(extracted_key)\n    if extracted_key != key:\n        raise Exception(extracted_key + ' != ' + key)"}
{"cell_type":"code","execution_count":81,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"1732584193"},"execution_count":81,"metadata":{},"output_type":"execute_result"}],"source":"message = b'comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon'\na = [ord(i) for i in message[:64]]\nb = 0x67452301 ^ 0xefcdab89\nb ^ 0xefcdab89"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 28 - Implement a SHA-1 keyed MAC\nTo do fix it..."}
{"cell_type":"code","execution_count":74,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"from Crypto.Util.strxor import strxor\n# Taken from https://github.com/sfstpala/SlowSHA\nclass SHA1 (object):\n    _default_h0, _default_h1, _default_h2, _default_h3, _default_h4, = (\n        0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0)\n\n    def __init__(self, message, h0 = _default_h0, h1 = _default_h1, h2 = _default_h2, h3 = _default_h3, h4 = _default_h4, length = None):\n        self._h0 = h0\n        self._h1 = h1\n        self._h2 = h2\n        self._h3 = h3\n        self._h4 = h4\n        if length is None:\n            length = len(message) * 8\n        length = bin(length)[2:].rjust(64, \"0\")\n        while len(message) > 64:\n            self._handle(''.join(bin(ord(i))[2:].rjust(8, \"0\") for i in message[:64]))\n            message = message[64:]\n        message = ''.join(bin(ord(i))[2:].rjust(8, \"0\") for i in message) + \"1\"\n        message += \"0\" * ((448 - len(message) % 512) % 512) + length\n        for i in range(len(message) // 512):\n            self._handle(message[i * 512:i * 512 + 512])\n\n\n    def _handle(self, chunk):\n\n        lrot = lambda x, n: (x << n) | (x >> (32 - n))\n        w = []\n\n        for j in range(len(chunk) // 32):\n            w.append(int(chunk[j * 32:j * 32 + 32], 2))\n\n        for i in range(16, 80):\n            w.append(lrot(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1)\n                & 0xffffffff)\n\n        a = self._h0\n        b = self._h1\n        c = self._h2\n        d = self._h3\n        e = self._h4\n        for i in range(80):\n\n            if i <= i <= 19:\n                f, k = d ^ (b & (c ^ d)), 0x5a827999\n            elif 20 <= i <= 39:\n                f, k = b ^ c ^ d, 0x6ed9eba1\n            elif 40 <= i <= 59:\n                f, k = (b & c) | (d & (b | c)), 0x8f1bbcdc\n            elif 60 <= i <= 79:\n                f, k = b ^ c ^ d, 0xca62c1d6\n                \n            temp = lrot(a, 5) + f + e + k + w[i] & 0xffffffff\n            a, b, c, d, e = temp, a, lrot(b, 30), c, d\n\n        self._h0 = (self._h0 + a) & 0xffffffff\n        self._h1 = (self._h1 + b) & 0xffffffff\n        self._h2 = (self._h2 + c) & 0xffffffff\n        self._h3 = (self._h3 + d) & 0xffffffff\n        self._h4 = (self._h4 + e) & 0xffffffff\n\n    def _digest(self):\n        return (self._h0, self._h1, self._h2, self._h3, self._h4)\n\n    def hexdigest(self):\n        print self._digest()\n        return ''.join(hex(i)[2:].rjust(8, \"0\") for i in self._digest())\n\n    def digest(self):\n        hexdigest = self.hexdigest()\n        tmpdigest = \"\"\n        for x in hexdigest.split('L'):\n            if len(x) < 8 and x !=\"\":\n                x = '0'+ x\n            tmpdigest = tmpdigest + x\n        hexdigest = tmpdigest\n        print hexdigest\n        return bytearray(int(hexdigest[i * 2:i * 2 + 2], 16) for i in range(len(hexdigest) // 2))\n        \ndef authSHA1(key, message):\n    return SHA1(key + message).digest()"}
{"cell_type":"code","execution_count":75,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"<type 'str'>\n(1532996819L, 126463833L, 25916121L, 2689734464L, 1872867844L)\n5b5facd30789af59018b72d9a05217406fa1b204\n"},{"data":{"text/plain":"20"},"execution_count":75,"metadata":{},"output_type":"execute_result"}],"source":"keylen = random.randint(0, 100)\nkey = randbytes(keylen)\nprint type(key)\nmessage = b'comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon'\nmessageDigest = authSHA1(key, message)\nlen(messageDigest)"}
{"cell_type":"markdown","metadata":{},"source":"### Challenge 29 - Break a SHA-1 keyed MAC using length extension\n\nSecret-prefix SHA1 的攻擊基於你可以拿 SHA-1 的output當新一輪的input。\n\n因為key在data前當secret-prefix，所以任何額外加入的data都會跟key有關\n\n實作上來說，你需要考慮SHA-1是經過padded成固定的bit-length。你偽造的message需要包含padding(glue padding)\n\n```\nSHA1(key || original-message || glue-padding || new-message)\n(where the final padding on the whole constructed message is implied)\n```\n\n注意要產生glue padding，你需要知道原來message的bit length，這部分需要用猜的(因為沒有key)\n\n先實作一個function，這個function計算任何message的MD padding，並確保你的實作符合規格\n\n接下來，偽造 SHA-1 hash並將他分為32 bit(SHA-1 calls them \"a\", \"b\", \"c\", &c).\n\n讓 SHA-1 implementation 能夠傳入新的 \"a\", \"b\", \"c\" &c (they normally start at magic numbers)，之後偽造額外的data\n\n用此攻擊製造出secret-prefix MAC (choose a random word from /usr/share/dict/words or something)或\n\n```\n\"comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon\"\n```\n\n偽造一個類似此的訊息結尾換成 \";admin=true\"."}
{"cell_type":"code","execution_count":68,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"('comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02p;admin=true', bytearray(b'\\xda\\xb1\\xfb6b\\xcb\\x01\\xec\\xf4N\\x05\\xa5\\xcb#\\xc9\\xbaS\\xc0\\xa4\\xbe'))\n"}],"source":"from Crypto.Random import random\nimport struct\n\ndef padSHA1(s):\n    l = len(s) * 8\n    s += b'\\x80'\n    s += b'\\x00' * ((56 - (len(s) % 64)) % 64)\n    s += struct.pack('>Q', l)\n    return s\n\nkeylen = random.randint(0, 100)\nkey = randbytes(keylen)\n\ndef validate(message, digest):\n    return authSHA1(key, message) == digest\n\nmessage = b'comment1=cooking%20MCs;userdata=foo;comment2=%20like%20a%20pound%20of%20bacon'\nmessageDigest = authSHA1(key, message)\n\ndef forgeHash(keylen, message, digest, suffix):\n    paddedForgedMessageWithKey = padSHA1(key + message) + suffix\n    forgedMessage = paddedForgedMessageWithKey[keylen:]\n    h = struct.unpack('>5I', digest)\n    forgedDigest = SHA1(suffix, h[0], h[1], h[2], h[3], h[4], len(paddedForgedMessageWithKey) * 8).digest()\n    return (forgedMessage, forgedDigest)\n\ndef forgeValidatingHash(maxkeylen, message, digest, suffix):\n    for i in range(maxkeylen):\n        (forgedMessage, forgedDigest) = forgeHash(i, message, digest, suffix)\n        if validate(forgedMessage, forgedDigest):\n            return(forgedMessage, forgedDigest)\n    raise Exception('unexpected')\n\nprint(forgeValidatingHash(100, message, messageDigest, b';admin=true'))"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"# Advance\n### Challenge 31 - Implement and break HMAC-SHA1 with an artificial timing leak\nSet 4 剩下來的題目是去做server的timing attack 這部分較複雜 有興趣的可以研究看看xd\n\n寫一個小型的 application 接收 URL 且有 \"file\" 和 \"signature\" 的argument\n```\nhttp://localhost:9000/test?file=foo&signature=46b4ec586117154dacd49d664e5d63fdc88efb51\n```\n\n用server generate 出一把HMAC key，然後去驗證request的signature對file是否valid(使用``==``去實作)\n\n接下來寫一個function，\"insecure_compare\", 實作 == operation 一次比較 1 byte並在碰到non-match時立即離開\n\n在 \"insecure_compare\"迴圈中加入  50ms sleep (sleep 50ms after each byte) \n\n若MAC not Valid 回傳 500， valid則回傳200.\n\n接下來用timing attack，寫一個程式來找出 valid MAC for any file.\n"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"%%writefile challenge31.py\n\n\nimport binascii\nimport sys\nimport time\nimport urllib2\n\n\ndef isValidSignature(file, signature):\n    start =time.clock()\n    try:\n        response = urllib2.urlopen('http://localhost:9000/test?file=' + file + '&signature=' + signature)\n        end = time.clock()\n        if response.status != 200:\n            raise Exception('unexpected status ' + str(response.status))\n        return (True, end - start)\n    except urllib2.HTTPError as e:\n        end = time.clock()\n        if e.code != 500:\n            raise\n        return (False, end - start)\n\ndef guessNextByte(file, knownBytes, delay):\n    suffixlen = 20 - len(knownBytes)\n    expectedDuration = delay * len(knownBytes) + 0.01\n    start = time.clock()\n\n    def print_info(i):\n        end = time.clock()\n        print('Made {0} requests in {1:.2f}s; rps = {2:.2f}, max rps = {3:.2f}'.format(i, end - start, i / (end - start), 1 / expectedDuration))\n\n    for i in range(256):\n        suffix = chr(i) + (b'\\x00' * (suffixlen - 1))\n        signature = knownBytes + suffix\n        _, duration = isValidSignature(file, binascii.hexlify(signature).decode('ascii'))\n        if duration > expectedDuration + 0.8 * delay:\n            print_info(i)\n            print duration, expectedDuration + 0.8 * delay\n            return knownBytes + chr(i)\n\n    raise Exception('unexpected')\n\ndef guessNextByte_b(file, knownBytes, delay):\n    suffixlen = 20 - len(knownBytes)\n    start = time.clock()\n\n    durations = [0] * 256\n\n    count = 10\n    for k in range(count):\n        for i in range(256):\n            suffix = chr(i) + (b'\\x00' * (suffixlen - 1))\n            signature = knownBytes + suffix\n            durations[i] += isValidSignature(file, binascii.hexlify(signature).decode('ascii'))[1]\n\n    end = time.clock()\n    print('Made {0} requests in {1:.2f}s; rps = {2:.2f}'.format(count * 256, end - start, count * 256 / (end - start)))\n\n    for i in range(256):\n        durations[i] /= count\n\n    avg_duration = sum(durations) / 256\n    argmax = max(range(256), key=lambda i: durations[i])\n\n    if durations[argmax] > avg_duration + 0.80 * delay:\n        return knownBytes + chr(argmax)\n    else:\n        return knownBytes[:-1]\n\nif __name__ == '__main__':\n    file = sys.argv[1]\n    knownBytes = b''\n    DELAY = 0.5\n    while True:\n        if len(knownBytes) == 20:\n            if isValidSignature(file, binascii.hexlify(knownBytes).decode('ascii'))[0]:\n                break\n            else:\n                knownBytes = knownBytes[:-1]\n        knownBytes = guessNextByte_b(file, knownBytes, DELAY)\n        print(binascii.hexlify(knownBytes))\n    print(binascii.hexlify(knownBytes))"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"%%writefile challenge31_server.py\n\n\nfrom Crypto.Util.strxor import strxor_c\nfrom Crypto.Util.strxor import strxor\nfrom Crypto.Random import random\nfrom Crypto.Util.strxor import strxor\n\nimport binascii\nimport BaseHTTPServer\nimport SocketServer\nimport time\nimport urlparse \n\n\ndef to_bytes(n, length, endianess='big'):\n    h = '%x' % n\n    s = ('0'*(len(h) % 2) + h).zfill(length*2).decode('hex')\n    return s if endianess == 'big' else s[::-1]\n\ndef randbytes(k):\n    return to_bytes(random.getrandbits(8*k), k)\n\nPORT = 9000\nDELAY = 0.05\n\nblocksize = 64\nkey = randbytes(100)\n\n# Taken from https://github.com/sfstpala/SlowSHA\nclass SHA1 (object):\n    _default_h0, _default_h1, _default_h2, _default_h3, _default_h4, = (\n        0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0)\n\n    def __init__(self, message, h0 = _default_h0, h1 = _default_h1, h2 = _default_h2, h3 = _default_h3, h4 = _default_h4, length = None):\n        self._h0 = h0\n        self._h1 = h1\n        self._h2 = h2\n        self._h3 = h3\n        self._h4 = h4\n        if length is None:\n            length = len(message) * 8\n        length = bin(length)[2:].rjust(64, \"0\")\n        while len(message) > 64:\n            self._handle(''.join(bin(ord(i))[2:].rjust(8, \"0\") for i in message[:64]))\n            message = message[64:]\n        message = ''.join(bin(ord(i))[2:].rjust(8, \"0\") for i in message) + \"1\"\n        message += \"0\" * ((448 - len(message) % 512) % 512) + length\n        for i in range(len(message) // 512):\n            self._handle(message[i * 512:i * 512 + 512])\n\n\n    def _handle(self, chunk):\n\n        lrot = lambda x, n: (x << n) | (x >> (32 - n))\n        w = []\n\n        for j in range(len(chunk) // 32):\n            w.append(int(chunk[j * 32:j * 32 + 32], 2))\n\n        for i in range(16, 80):\n            w.append(lrot(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1)\n                & 0xffffffff)\n\n        a = self._h0\n        b = self._h1\n        c = self._h2\n        d = self._h3\n        e = self._h4\n        for i in range(80):\n\n            if i <= i <= 19:\n                f, k = d ^ (b & (c ^ d)), 0x5a827999\n            elif 20 <= i <= 39:\n                f, k = b ^ c ^ d, 0x6ed9eba1\n            elif 40 <= i <= 59:\n                f, k = (b & c) | (d & (b | c)), 0x8f1bbcdc\n            elif 60 <= i <= 79:\n                f, k = b ^ c ^ d, 0xca62c1d6\n                \n            temp = lrot(a, 5) + f + e + k + w[i] & 0xffffffff\n            a, b, c, d, e = temp, a, lrot(b, 30), c, d\n\n        self._h0 = (self._h0 + a) & 0xffffffff\n        self._h1 = (self._h1 + b) & 0xffffffff\n        self._h2 = (self._h2 + c) & 0xffffffff\n        self._h3 = (self._h3 + d) & 0xffffffff\n        self._h4 = (self._h4 + e) & 0xffffffff\n\n    def _digest(self):\n        return (self._h0, self._h1, self._h2, self._h3, self._h4)\n\n    def hexdigest(self):\n        return ''.join(hex(i)[2:].rjust(8, \"0\")\n            for i in self._digest())\n\n    def digest(self):\n        hexdigest = self.hexdigest()\n        return bytearray(int(hexdigest[i * 2:i * 2 + 2], 16) for i in range(len(hexdigest) // 2))\n        \ndef authSHA1(key, message):\n    return SHA1(key + message).digest()\n\ndef sha1(x):\n    return SHA1(x).digest()\n\ndef hmacSHA1(key, message):\n    if len(key) > blocksize:\n        key = sha1(key)\n    if len(key) < blocksize:\n        key += b'\\x00' * (blocksize - len(key))\n\n    opad = strxor_c(key, 0x5c)\n    ipad = strxor_c(key, 0x36)\n\n    return sha1(opad + sha1(ipad + message))\n\ndef insecure_compare(x, y):\n    if len(x) != len(y):\n        return False\n    for i in range(len(x)):\n        if x[i] != y[i]:\n            return False\n        time.sleep(DELAY)\n    return True\n\nlast_file = b''\n\nclass RequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):\n    def do_GET(self):\n        global last_file\n        result = urlparse.urlparse(self.path)\n        if result.path == '/test':\n            q = urlparse.parse_qs(result.query)\n            file = q['file'][0].encode('ascii')\n            digest = hmacSHA1(key, file)\n            signature = binascii.unhexlify(q['signature'][0])\n            if file != last_file:\n                last_file = file\n                print('New file:', file, binascii.hexlify(digest))\n            print(binascii.hexlify(digest), binascii.hexlify(signature))\n            if insecure_compare(digest, signature):\n                self.send_error(200)\n            else:\n                self.send_error(500)\n        else:\n            self.send_error(500)\n\ndef serve_forever(delay):\n    global DELAY\n    DELAY = delay\n    SocketServer.TCPServer.allow_reuse_address = True\n    httpd = SocketServer.TCPServer((\"\", PORT), RequestHandler)\n    print(\"serving at port {0} with delay {1}\".format(PORT, DELAY))\n    httpd.serve_forever()\n\nif __name__ == '__main__':\n    serve_forever(DELAY)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":""}