{"notebook_name":"00_Basics.ipynb"}
"## Overview\nThe cryptography modules inside python are not as plentiful as other fields like machine learning or network secruity (see https://lwn.net/Articles/595790/). To the best of mour knowledge, the sympy provides somewhat complete cryptography tools http://docs.sympy.org/dev/_modules/sympy/crypto/crypto.html.\n\nIf you would like to get a flavor of cryopto, sage may be a good choice, and there are relative plenty source for it http://www.sagemath.org/library-publications.html#books.\n\nHowever, in this tutorial I will use pycrtpo and cryptography instead since it is directly builds upon python, and also contains a collections of great toolkit. See https://www.dlitz.net/software/pycrypto/doc/ and https://cryptography.io/en/latest/\n\n> Other python biding like pynacl may also be helpful, keep track with it!!"︡{"metadata":{"collapsed":false,"trusted":true},"cell_type":"markdown"}
"## Pycrypto\nHow can we do it (only pairing x)"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"markdown"}
"from Crypto.Cipher import AES\nkey = 'starpasswordhere'\nplaintext = 'Martinet is god!'\n \nencobj = AES.new(key, AES.MODE_ECB)\nciphertext = encobj.encrypt(plaintext)\n\nprint ciphertext.encode('hex') "︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":10,"outputs":[{"output_type":"stream","text":"292138362368e0cdd76508781b3f3b82\n","name":"stdout"}]}
"> You might have noticed that the length of hex-encoded ciphertext is 32 characters. By encoding it in hex, we've doubled the size because each binary character is represented by two hex characters, thus the actual ciphertext is only 16 characters\n\n> The common encoding way in cryptography is **base64** (which is the same as many other applications), see http://blog.rlr-uk.com/2011/03/base64-encoding-is-not-cryptography.html for the reason\n\n> You may notice that we could not change the size of key and plaintext arbitrary in this example, we will relax this constraint by padding and some kdf (key derivation function) in later sections"︡{"metadata":{},"cell_type":"markdown"}
"import binascii\n \nkey = 'starpasswordhere'\nciphertext = binascii.unhexlify('292138362368e0cdd76508781b3f3b82')\n \ndecobj = AES.new(key, AES.MODE_ECB)\nplaintext = decobj.decrypt(ciphertext)\n \n# Resulting plaintext\nprint plaintext"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":11,"outputs":[{"output_type":"stream","text":"Martinet is god!\n","name":"stdout"}]}
"## Cryptography\nLet's see another well-documented toolbox cryptography(exactly the name!!)"︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"markdown"}
"from cryptography.hazmat.primitives.ciphers import (\n    Cipher, algorithms, modes\n)\nfrom cryptography.hazmat.backends import default_backend\nkey = 'starpasswordhere'\nplaintext = 'Martinet is god!'\nencryptor = Cipher(algorithms.AES(key),modes.ECB(),backend=default_backend()).encryptor()\nciphertext = encryptor.update(plaintext) + encryptor.finalize()\nprint ciphertext.encode('hex') "︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":14,"outputs":[{"output_type":"stream","text":"292138362368e0cdd76508781b3f3b82\n","name":"stdout"}]}
"decryptor = Cipher(algorithms.AES(key), modes.ECB(), backend=default_backend()).decryptor()\nplaintext = decryptor.update(ciphertext) + decryptor.finalize()\nprint plaintext"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":17,"outputs":[{"output_type":"stream","text":"Martinet is god!\n","name":"stdout"}]}
""︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"code","execution_count":null,"outputs":[]}