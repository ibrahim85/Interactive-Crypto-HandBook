{"kernelspec":{"display_name":"Python 2 (Ubuntu, plain)","language":"python","name":"python2-ubuntu"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"},"name":"01_AES.ipynb"}
{"cell_type":"markdown","metadata":{},"source":"# Symmetric Key Encryption\n\nSymmetric keys 演算法可分為: stream and block ciphers. \n\n- Stream ciphers 作用在data stream上, i.e. 一次1 bit 或 1 byte\n- Block ciphers 作用在 blocks of data, 例如一次 16 bytes "}
{"cell_type":"markdown","metadata":{},"source":"## Block Cipher\n\n### AES\n最廣為使用的 symmetric cipher 和 standard 是 the AES block cipher, 見 [FIPS PUB 197](http://csrc.nist.gov/publications/fips/fips197) \n\n建議可先看[這個](http://www.formaestudio.com/rijndaelinspector/archivos/Rijndael_Animation_v4_eng.swf) 動畫來複習AES!\n\n### Padding\n\n第一步我們先進行放寬第一章所說的byte長度的問題\n\n> AES 為 Rijndael cipher的一部分. AES 以 128-bits (16 bytes) 固定為BLOCK SIZE; 而data必須經過padding來滿足block size的倍數.例如 \"ABCDABCDABCDABCDABCDABCDABCDABCD\" 這樣的訊息不用做padding。 但若訊息是 \"ABCDABCDABCDABCDABCDABCDABCD\" 則需要 4 byte的 padding\n\n> 一個常見的padding scheme為將 0x80 當作第一個padding的byte，然後用 0x00 填滿剩下的padding。 例如前述例子會變成:\"ABCDABCDABCDABCDABCDABCDABCD\\x80\\x00\\x00\\x00\"\n\n我們先定義一個padding函式"}
{"cell_type":"code","execution_count":19,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"def pad_data(data):\n    \"\"\"pad_data pads out the data to an AES block length.\"\"\"\n    # return data if no padding is required\n    if len(data) % 16 == 0:\n        return data\n    # subtract one byte that should be the 0x80\n    # if 0 bytes of padding are required, it means only\n    # a single \\x80 is required.\n    padding_required = 15 - (len(data) % 16)\n\n    data = '%s\\x80' % data\n    data = '%s%s' % (data, '\\x00' * padding_required)\n    return data\n\ndef unpad_data(data):\n    \"\"\"unpad_data removes padding from the data.\"\"\"\n    if not data:\n        return data\n\n    data = data.rstrip('\\x00')\n    if data[-1] == '\\x80':\n        return data[:-1]\n    else:\n        return data"}
{"cell_type":"markdown","metadata":{},"source":"### Cipher mode\n#### CBC\n實務上用block cipher加密不會只加密一個block，所以我們必須先選mode. 常見的mode 包含 cipher block chaining or **CBC mode** or counter **CTR mode** (See Cryptography Engineering by Bruce Schneier). \n\n還有其他像**cipher feedback (CFB)**, **output feedback (OFB)** 及 **electronic codebook (ECB)**. CBC mode 是被廣泛使用的一種mode，我們會以他為主來探討。進一步來說 Cipher block chaining 會去 XORing 前一個 ciphertext block 和目前的 block.而一開始的bootstrap機制是用 **initialisation vector (IV)**來達成. 這需要一連串的randomly-generated bytes,並且要夠random無法反推!!\n\n> 加解密最重要的部分之一是正確的產生 random data.我們會採用 PyCrypto library’s 中的 _Crypto.Random.OSRNG module_. 記住當我們有更多的 entropy sources (例如 network traffic 和 disk activity), 系統就能更快速的產生 cryptographically-secure random data. 下面我們寫一個適用於linux系統產生 initialisation vector 的function. 注意 gmp library 可以更新到  5.0 (timing attack resistant) or 6.0 (side channel silence mode) 來對抗 physical attacks.\n\n![](https://i.imgur.com/dF9LU1z.png)\n\n\n#### Randome number"}
{"cell_type":"code","execution_count":20,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"import Crypto.Random.OSRNG.posix as RNG\nimport Crypto.Cipher.AES as AES \ndef generate_nonce():\n    \"\"\"Generate a random number used once.\"\"\"\n    return RNG.new().read(AES.block_size)"}
{"cell_type":"code","execution_count":21,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"(\"\\x06')\\xf9b\\xebd\\xb5\\xbc\\x84b\\xdb\\xec\\xdc\\xaeS0\\\\\\x96\\x9d\\xca-\\xdbT\\xdf\\xfb\\x93gY*\\x0c\\xc2\",\n str)"},"execution_count":21,"metadata":{},"output_type":"execute_result"}],"source":"nonce =  generate_key()\nnonce, type(nonce)"}
{"cell_type":"markdown","metadata":{},"source":"> 注意 python 內建的 random module 為MT19937 是完全可預測的. 並不適合拿來寫 cryptographic code"}
{"cell_type":"markdown","metadata":{},"source":"### Key generation\n\nSymmetric ciphers 的名稱便是雙方擁有一樣的金鑰. AES 有三種key size: **128-bit, 192-bit, and 256-bit, 或計做 16-byte, 24-byte, and 32-byte key sizes**. 這邊我們產生隨機的32 byte並記住他~~"}
{"cell_type":"code","execution_count":22,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"KEY_SIZE = 32\ndef generate_key():\n     return RNG.new().read(KEY_SIZE)"}
{"cell_type":"code","execution_count":23,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"('2!:d\\xd0\\xc2\\xa7gJk\\xc9 \\xab\\xcbj\\x95cp?t\\xb7[\\n\\x05\\x0b\\xcd\\x94\\xf4\\x19@\\xf8\\xd4',\n str)"},"execution_count":23,"metadata":{},"output_type":"execute_result"}],"source":"key =  generate_key()\nkey, type(key)"}
{"cell_type":"markdown","metadata":{},"source":"### Encryption/Decryption\n\n我們可以用這把key來加解密資料。加密的話我們需要 initialisation vector (i.e. a nonce), key, 和 data(plaintext). 然而, **IV isn’t a secret**. 當我們加密時IV會 prepend 在 encrypted data and make 前. 所以我們必須要對每一個新的plaintext產生新的random IV "}
{"cell_type":"code","execution_count":24,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def encrypt(data, key):\n     \"\"\"\n     Encrypt data using AES in CBC mode. The IV is prepended to the\n     ciphertext.\n     \"\"\"\n     data = pad_data(data)\n     ivec = generate_nonce()\n     aes = AES.new(key, AES.MODE_CBC, ivec)\n     ctxt = aes.encrypt(data)\n     return ivec + ctxt # 16 byte IV + 16 byte \n \n \ndef decrypt(ciphertext, key):\n     \"\"\"\n     Decrypt a ciphertext encrypted with AES in CBC mode; assumes the IV\n     has been prepended to the ciphertext.\n     \"\"\"\n     if len(ciphertext) <= AES.block_size:\n         raise Exception(\"Invalid ciphertext.\")\n     ivec = ciphertext[:AES.block_size]\n     ciphertext = ciphertext[AES.block_size:]\n     aes = AES.new(key, AES.MODE_CBC, ivec)\n     data = aes.decrypt(ciphertext)\n     return unpad_data(data)"}
{"cell_type":"code","execution_count":29,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"32 9\n32 �獏b��\u001c�_���t��\u001f�,:\u001d\f�\u0005XB�D@\r\u001a� 93e78d8f62bda31cde5fbc8be274fe881fb42c3a1d0cd8055842f944400d1af5\nMartinet!\n"}],"source":"key = generate_key()\nplaintext = 'Martinet!'\n\nprint len(key), len(plaintext)\n \nciphertext = encrypt(plaintext, key)\n\nprint len(ciphertext), ciphertext, ciphertext.encode('hex') # 印出好看用!\n\nplaintext = decrypt(ciphertext, key)\n \n# Resulting plaintext\nprint plaintext"}
{"cell_type":"markdown","metadata":{},"source":"### Authenticate\n\n不過要注意的是 AES 僅確保了 confidentiality. 我們常常還需要 **integrity and authenticity** 等服務\n\n或許直覺會想到MD5或SHA，不過他們缺點是digest可以被隨意改變(且MD5已不再安全)。\n\n這邊我們需要的是, 將 hash function 加入 key 來產生 digest。也就是我們需要 HMAC (which is a general framework)。另外，實務上我們不會用跟加密一樣的key。 我們需要的是 **new, freshly generated key**。\n\n這個framework中，我們需要加入SHA函數.因為我們使用 AES-256, 所以必須使用 SHA-512 (Remember the birthday attack~). 我們的 message tags 是經由 HMAC-SHA-512 來計算. 將產生 64-byte digest. 我們以下定義一些constant~"}
{"cell_type":"code","execution_count":31,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"__AES_KEYLEN = 32\n__TAG_KEYLEN = 64\n__TAG_LEN = __TAG_KEYLEN\n#KEYSIZE = __AES_KEYLEN + __TAG_KEYLEN"}
{"cell_type":"code","execution_count":32,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"import Crypto.Hash.HMAC as HMAC\nimport Crypto.Hash.SHA512 as SHA512\n \ndef new_tag(ciphertext, key):\n     \"\"\"Compute a new message tag using HMAC-SHA-512.\"\"\"\n     return HMAC.new(key, msg=ciphertext, digestmod=SHA512).digest()"}
{"cell_type":"markdown","metadata":{},"source":"這是我們修改後的加密函式!"}
{"cell_type":"code","execution_count":37,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def encrypt(data, key):\n    \"\"\"\n    Encrypt data using AES in CBC mode. The IV is prepended to the\n    ciphertext.\n    \"\"\"\n    data = pad_data(data)\n    ivec = generate_nonce()\n    aes = AES.new(key[:__AES_KEYLEN], AES.MODE_CBC, ivec)\n    ctxt = aes.encrypt(data)\n    tag = new_tag(ivec + ctxt, key[__AES_KEYLEN:]) \n    return ivec + ctxt + tag"}
{"cell_type":"markdown","metadata":{},"source":"#### Timing attack\n\n解密做的事是確認我們的 message tag 必須正確。 然而一般來說直接使用 == 會循序進行比對每一個byte並在第一次不對的時候就跳出(純速度考量)。 這樣的比對會遭遇 **timing attack**。在python中我們可以用 streql package (i.e. pip install streql) 來進行 constant-time 的比對"}
{"cell_type":"code","execution_count":38,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"import streql\ndef verify_tag(ciphertext, key):\n    \"\"\"Verify the tag on a ciphertext.\"\"\"\n    tag_start = len(ciphertext) - __TAG_LEN\n    data = ciphertext[:tag_start]\n    tag = ciphertext[tag_start:]\n    actual_tag = new_tag(data, key)\n    return streql.equals(actual_tag, tag)"}
{"cell_type":"code","execution_count":39,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def decrypt(ciphertext, key):\n     \"\"\"\n     Decrypt a ciphertext encrypted with AES in CBC mode; assumes the IV\n     has been prepended to the ciphertext.\n     \"\"\"\n     if len(ciphertext) <= AES.block_size:\n         return None, False\n     tag_start = len(ciphertext) - __TAG_LEN\n     ivec = ciphertext[:AES.block_size]\n     data = ciphertext[AES.block_size:tag_start]\n     if not verify_tag(ciphertext, key[__AES_KEYLEN:]):\n         return None, False\n     aes = AES.new(key[:__AES_KEYLEN], AES.MODE_CBC, ivec)\n     data = aes.decrypt(data)\n     return unpad_data(data), True"}
{"cell_type":"code","execution_count":41,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"32 9\n96 �l���M�\u000b\u0014w(i\u00183zjg��\\D\u0001\u001a����\u0012���Y��Q�H\u001a��H�Z1t�\u0002��b\n�O\u0003�25\u0012s���w:�vp���,As�<HĞ2����e>9�i'���a c46cd0f3f34dc50b1477286918337a6a679ec85c44011ad8cde0a2fd12f7f2d7599390519e481ac9f148e05a3174f802b3ae620ac84f03dd32351273cfecf4773adf767082ceee2c4173a23c48c49e32d3eda9a1a4ed653e398b692784a48b61\n"}],"source":"key = generate_key()\nplaintext = 'Martinet!'\n\nprint len(key), len(plaintext)\n \nciphertext = encrypt(plaintext, key)\n\nprint len(ciphertext), ciphertext, ciphertext.encode('hex') # 印出好看用!"}
{"cell_type":"code","execution_count":42,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"('Martinet!', True)\n"}],"source":"plaintext = decrypt(ciphertext, key)\n \n# Resulting plaintext\nprint plaintext"}
{"cell_type":"markdown","metadata":{},"source":"> 另外還有其他值得注意的模式像是 CTR, GCM, XTS(Cipher Stealing的技巧，常用於disk加密)\n\n\n### Key Derivation Function\n\n前述我們是使用隨機產生的金鑰，在現實生活中我比較常見們比較常見的做法是讓使用者輸入password然後將其經過處理轉成金鑰。因此我們會需要一個 key derivation algorithm，像是PBKDF2。 這類function通常還會需要 salt來增加安全度。因此 PBKDf2 有三個輸入；passphrase, salt, 和迴圈跑的次數. 目前普遍認為安全的 iterations 為 16384。\n\n> Salt是什麼? Salt 是隨機產生的數，他可以確保KDF在相同 passphrase 下有不同結果。 通常來說他的長度要求為 16 bytes (128-bits).\n\n接下來我們實做兩個函數： generate a random salt 和 generate a secret key from PBKDF2:"}
{"cell_type":"code","execution_count":43,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"import pbkdf2 \n\ndef generate_salt(salt_len):  \n    \"\"\"Generate a salt for use with PBKDF2.\"\"\"\n    return RNG.new().read(salt_len)\n\ndef password_key(passphrase, salt=None):\n    \"\"\"Generate a key from a passphrase. Returns the tuple (salt, key).\"\"\"\n    if salt is None:\n        salt = generate_salt(16)\n    passkey = pbkdf2.PBKDF2(passphrase, salt, iterations=16384).read(KEYSIZE)\n    return salt, passkey"}
{"cell_type":"code","execution_count":46,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"('+\\xf6\\xfc0a\\x1c\\xf8\\x02\\xaa\\x90\\xbdw\\x1f\\xf3Z\\xbb', '\\xc1\\xe2K\\xa2\\xea\\x11\\x0ce\\xd4\\xc91\\x16\\x86\\x8b\\xdby%\\x06\\x9f\\x15d\\xb3\\x85c:O8b;\\x95\\x94\\xb3')\n"}],"source":"keyin = 'star'\nsalt, key = password_key(keyin)\nprint (salt, key)"}
{"cell_type":"markdown","metadata":{},"source":"注意salt也是公開的，他也必須存下來來還原key，可以用同樣的方法例如頭 len(salt) bytes 附加在 ciphertext前面。"}
{"cell_type":"markdown","metadata":{},"source":"### ASCII-Armouring"}
{"cell_type":"markdown","metadata":{},"source":"有些人會習慣用base64 encode來處理， 而不是用binary data。接下來試一個完整的範例。"}
{"cell_type":"code","execution_count":47,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"keyin = 'star'\nplaintext = 'AG is god'\nsalt, key = password_key(keyin)\nciphertext = encrypt(plaintext, key)"}
{"cell_type":"code","execution_count":48,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"('AG is god', True)\n"}],"source":"print decrypt(ciphertext, key)"}
{"cell_type":"markdown","metadata":{},"source":"### Yet another AES example\n\n下面我們舉加密圖片來看看各種Block cipher mode的範例。"}
{"cell_type":"code","execution_count":49,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"import sys\nimport os\nimport math\nfrom collections import Counter\n\n%matplotlib inline\nimport matplotlib.pyplot as plt\nfrom PIL import Image\nfrom Crypto.Cipher import AES"}
{"cell_type":"code","execution_count":50,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"IV_SIZE = 16\nBLOCK_SIZE = 16"}
{"cell_type":"code","execution_count":51,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def fn_entropy(s):\n    p, lns = Counter(s), float(len(s))\n    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())"}
{"cell_type":"code","execution_count":52,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"def encrypt_image(cipher_mode):\n    \"\"\"Encrypt an image file and write out the results as a JPEG.\"\"\"\n\n    input_image = Image.open(os.getcwd() + '/yuwen.jpg')\n    print input_image\n    plt.figure(figsize=(16,6))\n    plt.subplot(121)\n    plt.imshow(input_image)\n\n    # Key must be one of 16/24/32 bytes in length.\n    key = \"0123456789ABCDEF\"\n    if cipher_mode == 'ECB':\n        mode = AES.MODE_ECB\n    elif cipher_mode == 'CBC':\n        mode = AES.MODE_CBC\n    elif cipher_mode == 'CFB':\n        mode = AES.MODE_CFB\n    elif cipher_mode == 'OFB':\n        mode = AES.MODE_OFB\n    iv = os.urandom(IV_SIZE)\n\n    aes = AES.new(key, mode, iv)\n\n    image_string = input_image.tobytes()\n    # The input string must be padded to the input block size.\n    image_padding_length = BLOCK_SIZE - len(image_string) % BLOCK_SIZE\n    image_string += image_padding_length * \"~\"\n\n    # generate the encrypted image string\n    encrypted = aes.encrypt(image_string)\n\n    # create an image from the encrypted string\n    encrypted_img = Image.frombuffer(\"RGB\", input_image.size, encrypted, 'raw', \"RGB\", 0, 1)\n    \n    plt.subplot(122)\n    plt.imshow(encrypted_img)\n    plt.show()\n    \n    # create and save the output image\n    # encrypted_img.save(output_filename, 'PNG')\n\n    print(\"Encrypted using AES in \" + cipher_mode + \" mode!\")\n    print 'Entropy on original:  ', fn_entropy(image_string)\n    print 'Entropy on encryption: ', fn_entropy(encrypted_img.tobytes())"}
{"cell_type":"code","execution_count":53,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def encrypt_text(text,cipher_mode):\n    \n    # Key must be one of 16/24/32 bytes in length.\n    key = \"0123456789ABCDEF\"\n    if cipher_mode == 'ECB':\n        mode = AES.MODE_ECB\n    elif cipher_mode == 'CBC':\n        mode = AES.MODE_CBC\n    elif cipher_mode == 'CFB':\n        mode = AES.MODE_CFB\n    elif cipher_mode == 'OFB':\n        mode = AES.MODE_OFB\n    iv = os.urandom(IV_SIZE)\n\n    aes = AES.new(key, mode, iv)\n    \n    # Padding\n    # The input string must be padded to the input block size.\n    text_padding_length = BLOCK_SIZE - len(text) % BLOCK_SIZE\n    text += text_padding_length * \"~\"\n    text += text\n    \n    text_enc = aes.encrypt(text)\n    \n    print(\"Encrypted using AES in \" + cipher_mode + \" mode!\")\n    print 'Input text:     ', text\n    print 'Encrypted text: ', text_enc.encode('hex')\n    ####"}
{"cell_type":"code","execution_count":54,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Encrypted using AES in ECB mode!\nInput text:      Hello World~~~~~Hello World~~~~~\nEncrypted text:  bd3a2268346f62d2af6f0a4349e3e5abbd3a2268346f62d2af6f0a4349e3e5ab\n"}],"source":"encrypt_text('Hello World','ECB')"}
{"cell_type":"code","execution_count":55,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"Encrypted using AES in CBC mode!\nInput text:      Hello World~~~~~Hello World~~~~~\nEncrypted text:  9db759a7a247fd16d966feaae804d135b6a0b2d221b6ef7a67f04414176b7c56\n"}],"source":"encrypt_text('Hello World','CBC')"}
{"cell_type":"code","execution_count":56,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"<PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=960x960 at 0x7FE51868DD40>\n"},{"data":{"image/png":"smc-blob::77d19826-5c78-44bd-b2b3-90f942d88e07","text/plain":"<matplotlib.figure.Figure at 0x7fe518658e90>"},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":"Encrypted using AES in ECB mode!\nEntropy on original:   7.00650054307\nEntropy on encryption:  7.80861248594\n"}],"source":"encrypt_image('ECB')"}
{"cell_type":"markdown","metadata":{},"source":"上圖 (Mon god) 有加密嗎?"}
{"cell_type":"code","execution_count":57,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"<PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=960x960 at 0x7FE518694488>\n"},{"data":{"image/png":"smc-blob::359589b0-8526-4fbb-9569-66225cfd610c","text/plain":"<matplotlib.figure.Figure at 0x7fe54c7699d0>"},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":"Encrypted using AES in CBC mode!\nEntropy on original:   7.00650054307\nEntropy on encryption:  7.99993746339\n"}],"source":"encrypt_image('CBC')"}
{"cell_type":"code","execution_count":58,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"<PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=960x960 at 0x7FE51861FFC8>\n"},{"data":{"image/png":"smc-blob::d53d669c-addb-4d20-9973-84d6296a334d","text/plain":"<matplotlib.figure.Figure at 0x7fe510bf7410>"},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":"Encrypted using AES in CFB mode!\nEntropy on original:   7.00650054307\nEntropy on encryption:  7.99992150052\n"}],"source":"encrypt_image('CFB')"}
{"cell_type":"code","execution_count":59,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"<PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=960x960 at 0x7FE511BC6908>\n"},{"data":{"image/png":"smc-blob::13fcfee8-553f-4a96-8716-4ffa2384e365","text/plain":"<matplotlib.figure.Figure at 0x7fe511bdcb50>"},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":"Encrypted using AES in OFB mode!\nEntropy on original:   7.00650054307\nEntropy on encryption:  7.9999289088\n"}],"source":"encrypt_image('OFB')"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"### Cryptography\n我們用 _cryptography toolkit_來看看一個新的mode - GCM (包含加解密和認證)"}
{"cell_type":"code","execution_count":60,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"import os\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import (\n    Cipher, algorithms, modes\n)\n\ndef encrypt(key, plaintext, associated_data):\n    # Generate a random 96-bit IV.\n    iv = os.urandom(12)\n\n    # Construct an AES-GCM Cipher object with the given key and a\n    # randomly generated IV.\n    encryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv),\n        backend=default_backend()\n    ).encryptor()\n\n    # associated_data will be authenticated but not encrypted,\n    # it must also be passed in on decryption.\n    encryptor.authenticate_additional_data(associated_data)\n\n    # Encrypt the plaintext and get the associated ciphertext.\n    # GCM does not require padding.\n    ciphertext = encryptor.update(plaintext) + encryptor.finalize()\n\n    return (iv, ciphertext, encryptor.tag)\n\ndef decrypt(key, associated_data, iv, ciphertext, tag):\n    # Construct a Cipher object, with the key, iv, and additionally the\n    # GCM tag used for authenticating the message.\n    decryptor = Cipher(\n        algorithms.AES(key),\n        modes.GCM(iv, tag),\n        backend=default_backend()\n    ).decryptor()\n\n    # We put associated_data back in or the tag will fail to verify\n    # when we finalize the decryptor.\n    decryptor.authenticate_additional_data(associated_data)\n\n    # Decryption gets us the authenticated plaintext.\n    # If the tag does not match an InvalidTag exception will be raised.\n    return decryptor.update(ciphertext) + decryptor.finalize()"}
{"cell_type":"code","execution_count":61,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"a secret message!\n"}],"source":"iv, ciphertext, tag = encrypt(key,b\"a secret message!\",b\"authenticated but not encrypted payload\")\n\nprint(decrypt(key,b\"authenticated but not encrypted payload\",iv,ciphertext,tag))"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"### The Recipe Layer"}
{"cell_type":"markdown","metadata":{},"source":"上述要實現一個安全的演算法所要考量的事情很多，因此有些library便會統一提供單一介面能夠更加安全的使用，當然缺點就是失去一些選擇的彈性(演算法，padding方式、安全速度tradeoff等)\n\nFernet 建構在一系列 standard cryptographic primitives上 包含:\n\n- AES in CBC mode, 128-bit key; 用 PKCS7 padding.\n- HMAC 用 SHA256 來認證.\n- Initialization vectors 用 os.urandom() (而非語言內建)\n\n> 大多專家會建議使用 operating system 的 random number generator，在python可透過 os.urandom()存取。在UNIX系統中他會拿 /dev/urandom 在windows會用 CryptGenRandom\n\n\n因此我們要注意的只剩key的產生: \t\n```\nkey (bytes) – A URL-safe base64-encoded 32-byte key. This must be kept secret. Anyone with this key is able to create and read messages.\n```"}
{"cell_type":"code","execution_count":62,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"'gAAAAABXfQg_cOCL7qqoFiH-jLu79z3oCWwhvjlxWxJRESyz8_8I38etX3wmXPL6Scn5wvlaDrKvOhtQefzUcW5pcNnWRWfCpg=='"},"execution_count":62,"metadata":{},"output_type":"execute_result"}],"source":"import base64\nimport os\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\npassword = b\"password\"\nsalt = os.urandom(16)\nkdf = PBKDF2HMAC(\n    algorithm=hashes.SHA256(),\n    length=32,\n    salt=salt,\n    iterations=100000,\n    backend=default_backend()\n)\nkey = base64.urlsafe_b64encode(kdf.derive(password))\nf = Fernet(key)\ntoken = f.encrypt(b\"Secret message!\")\ntoken"}
{"cell_type":"code","execution_count":63,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"'Secret message!'"},"execution_count":63,"metadata":{},"output_type":"execute_result"}],"source":"f.decrypt(token)"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"## Stream Cipher\n\n我們可以使用pynacl來使用Salsa20這類由eStream 選出來的新型stream cipher"}
{"cell_type":"code","execution_count":8,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<module 'nacl' from '/usr/lib/python2.7/dist-packages/nacl/__init__.pyc'>"},"execution_count":8,"metadata":{},"output_type":"execute_result"}],"source":"import nacl\nnacl"}
{"cell_type":"code","execution_count":9,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"import nacl.secret\nimport nacl.utils\n\n# This must be kept secret, this is the combination to your safe\nkey = nacl.utils.random(nacl.secret.SecretBox.KEY_SIZE)\n\n# This is your safe, you can use it to encrypt or decrypt messages\nbox = nacl.secret.SecretBox(key)\n\n# This is our message to send, it must be a bytestring as SecretBox will\n#   treat is as just a binary blob of data.\nmessage = b\"The president will be exiting through the lower levels\"\n\n# This is a nonce, it *MUST* only be used once, but it is not considered\n#   secret and can be transmitted or stored alongside the ciphertext. A\n#   good source of nonce is just 24 random bytes.\nnonce = nacl.utils.random(nacl.secret.SecretBox.NONCE_SIZE)\n\n# Encrypt our message, it will be exactly 40 bytes longer than the original\n#   message as it stores authentication information and nonce alongside it.\nencrypted = box.encrypt(message, nonce)\n\n# Decrypt our message, an exception will be raised if the encryption was\n#   tampered with or there was otherwise an error.\nplaintext = box.decrypt(encrypted)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}