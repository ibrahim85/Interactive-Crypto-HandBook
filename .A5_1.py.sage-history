"#!/usr/bin/env python\n##  This is a Python implementation of the C code provided by Marc Briceno, Ian\n##  Goldberg, and David Wagner at the following website:\n##\n##     http://www.scard.org/gsm/a51.html\n##\n##  For accuracy, compared the output of this Python code against the test\n##  vector provided by them.\n\n##  The A5/1 algorithm is used in 2G GSM for over-the-air encryption of voice and SMS\n##  data. On the basis of the cryptanalysis of this cipher and the more recent\n##  rainbow table attacks, the A5/1 algorithm is now considered to provide virtually\n##  no security at all.  Nonetheless, it forms an interesting case study that shows\n##  that when security algorithm are not opened up to public scrutiny (because some\n##  folks out there believe in \"security through obscurity\"), it is possible for such\n##  an algorithm to become deployed on a truly global basis before its flaws become\n##  evident.\n\n##  The A5/1 algorithm is a bit-level stream cipher based on three LFSR (Linear\n##  Feedback Shift Register). The basic operation you carry out in an LFSR at each\n##  clock tick consists of the following three steps: (1) You record the bits at the\n##  feedback taps in the register; (2) You shift the register by one bit position\n##  towards the MSB; and (3) You set the value of the LSB to an XOR of the feedback\n##  bits.  When you are first initializing a register with the encryption key, you\n##  add a fourth step, which is to XOR the LSB with the key bit corresponding to that\n##  clock tick, etc.\n\nfrom BitVector import *\n\n#  The three shift registers\nR1,R2,R3 = BitVector(size=19),BitVector(size=22),BitVector(size=23)                     #(1)\n\n# Feedback taps\nR1TAPS,R2TAPS,R3TAPS = BitVector(size=19),BitVector(size=22),BitVector(size=23)         #(2)\nR1TAPS[13] = R1TAPS[16] = R1TAPS[17] = R1TAPS[18] = 1                                   #(3)\nR2TAPS[20] = R2TAPS[21] = 1                                                             #(4)\nR3TAPS[7] = R3TAPS[20] = R3TAPS[21] = R3TAPS[22] = 1                                    #(5)\n\nprint \"R1TAPS: \", R1TAPS                                                                #(6)\nprint \"R2TAPS: \", R2TAPS                                                                #(7)\nprint \"R3TAPS: \", R3TAPS                                                                #(8)\n\nkeybytes = [BitVector(hexstring=x).reverse() for x in ['12', '23', '45', '67', \\\n                                                       '89', 'ab', 'cd', 'ef']]         #(9)\nkey = reduce(lambda x,y: x+y, keybytes)                                                #(10)\nprint \"encryption key: \", key                                                          #(11)\n\nframe = BitVector(intVal=0x134, size=22).reverse()                                     #(12)\nprint \"frame number: \", frame                                                          #(13)\n\n##  We will store the two output keystreams in these two BitVectors, each of size 114\n##  bits.  One is for the uplink and the other for the downlink:\nAtoBkeystream  = BitVector(size = 114)                                                 #(14)\nBtoAkeystream  = BitVector(size = 114)                                                 #(15)\n\n##  This function used by the clockone() function.  As each shift register is\n##  clocked, the feedback consists of the parity of all the tap bits:\ndef parity(x):                                                                         #(16)\n    countbits = x.count_bits()                                                         #(17)\n    return countbits  % 2                                                              #(18)\n\n##  In order to decide whether or not a shift register should be clocked at a given\n##  clock tick, we need to examine the clocking bits in each register and see what the\n##  majority says:\ndef majority():                                                                        #(19)\n    sum = R1[8] + R2[10] + R3[10]                                                      #(20)\n    if sum >= 2:                                                                       #(21)\n        return 1                                                                       #(22)\n    else:                                                                              #(23)\n        return 0                                                                       #(24)\n\n##  This function clocks just one register that is supplied as the first arg to the\n##  function.  The second argument must indicate the bit positions of the feedback\n##  taps for the register.\ndef clockone(register, taps):                                                          #(25)\n    tapsbits = register & taps                                                         #(26)\n    register.shift_right(1)                                                            #(27)\n    register[0] = parity(tapsbits)                                                     #(28)\n\n##  This function is needed for initializing the three shift registers.\ndef clockall():                                                                        #(29)\n    clockone(R1, R1TAPS)                                                               #(30)\n    clockone(R2, R2TAPS)                                                               #(31)\n    clockone(R3, R3TAPS)                                                               #(32)\n\n##  This function initializes the three shift registers with, first, the 64-bit\n##  encryption key, then with the 22 bits of frame number, and, finally, by simply\n##  clocking the registers 100 times to create the 'avalanche' effect.  Note that\n##  during the avalanche creation, clocking of each register now depends on the\n##  clocking bits in all three registers.\ndef setupkey():                                                                        #(33)\n    #  Clock into the registers the 64 bits of the encryption key:\n    for i in range(64):                                                                #(34)\n        clockall()                                                                     #(35)\n        R1[0] ^= key[i]; R2[0] ^= key[i]; R3[0] ^= key[i]                              #(36)\n    #  Clock into the registers the 22 bits of the frame number:\n    for i in range(22):                                                                #(37) \n        clockall()                                                                     #(38)\n        R1[0] ^= frame[i]; R2[0] ^= frame[i]; R3[0] ^= frame[i]                        #(39)\n    #  Now clock all three registers 100 times, but this time let the clocking\n    #  of each register depend on the majority voting of the clocking bits:\n    for i in range(100):                                                               #(40)\n        maj = majority()                                                               #(41)\n        if (R1[8]  != 0) == maj: clockone(R1, R1TAPS)                                  #(42)\n        if (R2[10] != 0) == maj: clockone(R2, R2TAPS)                                  #(43)\n        if (R3[10] != 0) == maj: clockone(R3, R3TAPS)                                  #(44)\n\n##  After the three shift registers are initialized with the encryption key and the\n##  frame number, you are ready to run the shift registers to produce the two bit 114\n##  bits long keystreams, one for the uplink and the other for the downlink.\ndef run():                                                                             #(45)\n    global AtoBkeystream, BtoAkeystream                                                #(46)\n    keystream = BitVector(size=228)                                                    #(47)\n    for i in range(228):                                                               #(48)\n        maj = majority()                                                               #(49)\n        if (R1[8]  != 0) == maj: clockone(R1, R1TAPS)                                  #(50)\n        if (R2[10] != 0) == maj: clockone(R2, R2TAPS)                                  #(51)\n        if (R3[10] != 0) == maj: clockone(R3, R3TAPS)                                  #(62)\n        keystream[i] = R1[-1] ^ R2[-1] ^ R3[-1]                                        #(53)\n    AtoBkeystream = keystream[:114]                                                    #(54)\n    BtoAkeystream = keystream[114:]                                                    #(55)\n\n##  Initialize the three shift registers:\nsetupkey()                                                                             #(56)\n##  Now produce the keystreams:\nrun()                                                                                  #(57)\n\n##  Display the two keystreams:\nprint \"\\nAtoBkeystream:       \", AtoBkeystream                                         #(58)\nprint \"\\nBtoAkeystream:       \", BtoAkeystream                                         #(59)\n\n##  Here are the correct values for the two keystreams:\ngoodAtoB = [BitVector(hexstring = x) for x in ['53','4e','aa','58','2f','e8','15','1a',\\\n                                               'b6','e1','85','5a','72','8c','00'] ]   #(60)     \ngoodBtoA = [BitVector(hexstring = x) for x in ['24','fd','35','a3','5d','5f','b6','52',\\\n                                               '6d','32','f9','06','df','1a','c0'] ]   #(61)\ngoodAtoB = reduce(lambda x,y: x+y, goodAtoB)                                           #(62)\ngoodBtoA = reduce(lambda x,y: x+y, goodBtoA)                                           #(63)\n\nprint \"\\nGood: AtoBkeystream: \", goodAtoB[:114]                                        #(64)\nprint \"\\nGood: BtoAkeystream: \", goodBtoA[:114]                                        #(65)\n\nif (AtoBkeystream == goodAtoB[:114]) and (AtoBkeystream == goodAtoB[:114]):            #(66)\n    print \"\\nSelf-check succeeded: Everything looks good\"                              #(67)\n"
{"patch":[[[[0,", etc.\n\n"],[1,"# Useful Package!\n"],[0,"from Bit"]],1510,1510,16,34]],"time":1456659718599}
{"patch":[[[[0," Package"],[-1,"!"],[0,"\nfrom Bi"]],1526,1526,17,16]],"time":1456653001500}
{"patch":[[[[0,"ul P"],[-1,"ackage"],[0,"\nfro"]],1524,1524,14,8]],"time":1456652999462}
{"patch":[[[[0," Useful "],[-1,"P"],[0,"\nfrom Bi"]],1519,1519,17,16]],"time":1456652997463}
{"patch":[[[[0,"# Us"],[-1,"eful "],[0,"\nfro"]],1518,1518,13,8]],"time":1456652995460}
{"patch":[[[[0,"c.\n\n"],[-1,"# Us"],[0,"\nfro"]],1514,1514,12,8]],"time":1456652993459}
{"patch":[[[[0,", etc.\n\n"],[-1,"\n"],[0,"from Bit"]],1510,1510,17,16]],"time":1456652991456}
{"patch":[[[[0,"y them.\n"],[1,"#"],[0,"\n##  The"]],302,302,16,17]],"time":1456652937876}
{"patch":[[[[0," them.\n#"],[1,"#"],[0,"\n##  The"]],303,303,16,17]],"time":1456652935878}
{"patch":[[[[0,"y them.\n"],[-1,"##"],[0,"\n##  The"]],302,302,18,16]],"time":1456652914685}
{"patch":[[[[0,"y them.\n"],[-1,"\n"],[0,"##  The "]],302,302,17,16]],"time":1456652912682}
{"patch":[[[[0,"y them.\n"],[1,"\n"],[0,"##  The "]],302,302,16,17]],"time":1456652905611}
{"patch":[[[[0,"ccuracy,"],[1," I have"],[0," compare"]],215,215,16,23]],"time":1456652902274}
{"patch":[[[[0,"a51.html"],[1,"      "],[0,"\n##\n##  "]],194,194,16,22]],"time":1456652896038}
{"patch":[[[[0," python\n"],[1,"\n\n"],[0,"##  This"]],14,14,16,18]],"time":1456652866280}
{"patch":[[[[0,"python\n\n"],[1,"##  A5_1.py\n##  Avi Kak (kak@purdue.edu)\n##  April 21, 2015\n"],[0,"\n##  Thi"]],15,15,16,76]],"time":1456652864285}