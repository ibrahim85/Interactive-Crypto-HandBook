{"kernelspec":{"display_name":"Python 2 (Ubuntu, plain)","language":"python","name":"python2-ubuntu"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{"collapsed":false,"trusted":false},"source":"## Caesar shift\n首先介紹shift cipher的代表，加密是透過shift字母固定長度，此長度為key，例如: “A” -> “C”,  “B” -> “D”"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"from functools import partial\n\nalpha = \"abcdefghijklmnopqrstuvwxyz\".upper()\npunct = \",.?:;'\\n \"\n\ndef shift(l, s=2):\n    l = l.upper()\n    return alpha[(alpha.index(l) + s) % 26]\n\ndef caesar_shift_encrypt(m, s=2):\n    m = m.upper()\n    c = \"\".join(map(partial(shift, s=s), m))\n    return c\n\ndef caesar_shift_decrypt(c, s=-2):\n    c = c.upper()\n    m = \"\".join(map(partial(shift, s=s), c))\n    return m"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Original Message:\nTobeornottobethatisthequestionWhethertisNoblerinthemindtosufferTheSlingsandArrowsofoutrageousFortuneOrtotakeArmsagainstaSeaoftroublesAndbyopposingendthem\n\nCiphertext:\nVQDGQTPQVVQDGVJCVKUVJGSWGUVKQPYJGVJGTVKUPQDNGTKPVJGOKPFVQUWHHGTVJGUNKPIUCPFCTTQYUQHQWVTCIGQWUHQTVWPGQTVQVCMGCTOUCICKPUVCUGCQHVTQWDNGUCPFDAQRRQUKPIGPFVJGO\nDecrypted second message:\nTOBEORNOTTOBETHATISTHEQUESTIONWHETHERTISNOBLERINTHEMINDTOSUFFERTHESLINGSANDARROWSOFOUTRAGEOUSFORTUNEORTOTAKEARMSAGAINSTASEAOFTROUBLESANDBYOPPOSINGENDTHEM\n"}],"source":"m = \"\"\"To be, or not to be, that is the question:\nWhether 'tis Nobler in the mind to suffer\nThe Slings and Arrows of outrageous Fortune,\nOr to take Arms against a Sea of troubles,\nAnd by opposing end them.\"\"\"\n\nm = \"\".join([l for l in m if not l in punct])\n\nprint \"Original Message:\"\nprint m\n\nprint\nprint \"Ciphertext:\"\ntobe_ciphertext = caesar_shift_encrypt(m)\nprint tobe_ciphertext\nprint \"Decrypted second message:\"\nprint caesar_shift_decrypt(tobe_ciphertext)"}
{"cell_type":"markdown","metadata":{},"source":"此種加密法key space為26"}
{"cell_type":"markdown","metadata":{},"source":"## Substitution cipher\n接下來的cipher改進的方法是建構出一個對照表， “A” -> “G” , “B” -> “E”，也就是替代的方法不是純粹的shift"}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"ABCDEFGHIJKLMNOPQRSTUVWXYZ\nRENPGFIBHAOXUMCKTYQLDSJWZV\n"}],"source":"import random\npermutation = list(alpha)\nrandom.shuffle(permutation)\n# Display the new table\nprint alpha\nsubs = \"\".join(permutation)\nprint subs"}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def subs_cipher_encrypt(m):\n    m = \"\".join([l.upper() for l in m if not l in punct])\n    return \"\".join([subs[alpha.find(l)] for l in m])\n\ndef subs_cipher_decrypt(c):\n    c = \"\".join([l.upper() for l in c if not l in punct])\n    return \"\".join([alpha[subs.find(l)] for l in c])"}
{"cell_type":"code","execution_count":6,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Original message:\nTobeornottobethatisthequestionWhethertisNoblerinthemindtosufferTheSlingsandArrowsofoutrageousFortuneOrtotakeArmsagainstaSeaoftroublesAndbyopposingendthem\n\nEncrypted Message:\nLCEGCYMCLLCEGLBRLHQLBGTDGQLHCMJBGLBGYLHQMCEXGYHMLBGUHMPLCQDFFGYLBGQXHMIQRMPRYYCJQCFCDLYRIGCDQFCYLDMGCYLCLROGRYUQRIRHMQLRQGRCFLYCDEXGQRMPEZCKKCQHMIGMPLBGU\n\nDecrypted Message:\nTOBEORNOTTOBETHATISTHEQUESTIONWHETHERTISNOBLERINTHEMINDTOSUFFERTHESLINGSANDARROWSOFOUTRAGEOUSFORTUNEORTOTAKEARMSAGAINSTASEAOFTROUBLESANDBYOPPOSINGENDTHEM\n"}],"source":"print \"Original message:\"\nprint m\n\nprint\nc2 = subs_cipher_encrypt(m)\nprint \"Encrypted Message:\"\nprint c2\n\nprint\nprint \"Decrypted Message:\"\nprint subs_cipher_decrypt(c2)"}
{"cell_type":"markdown","metadata":{},"source":"不過此種加密法的缺點是他無法改變字母出現的頻率，也就是說我們的語言中，字母出現的頻率不同，進一步來說diagram, triagram(一次看兩到三個字母)也存在相同特性，因此我們可以分析密文中的頻率而不是直接去攻擊26!的key space"}
{"cell_type":"markdown","metadata":{},"source":"## Enigma"}
{"cell_type":"code","execution_count":7,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"from random import shuffle,randint,choice  \nfrom copy import copy  \nnum_alphabet = range(26)   \n    \ndef en_shift(l, n):                         # Rotate cogs and arrays\n    return l[n:] + l[:n]  \n      \n    \nclass Cog:                                  # Each cog has a substitution cipher  \n    def __init__(self):  \n        self.shuf = copy(num_alphabet)  \n        shuffle(self.shuf)                  # Create the individual substition cipher\n        return                              # Really, these were not random\n    \n    def subs_in(self,i):                    # Perform a substition\n        return self.shuf[i] \n    \n    def subs_out(self,i):                   # Perform a reverse substition\n        return self.shuf.index(i)\n    \n    def rotate(self):                       # Rotate the cog by 1.\n        self.shuf = en_shift(self.shuf, 1)\n        \n    def setcog(self,a):                     # Set up a particular substitution\n        self.shuf = a  \n\n        \nclass Enigma:  \n    def __init__(self, numcogs,readability=True):  \n        self.readability = readability  \n        self.numcogs = numcogs  \n        self.cogs = []  \n        self.oCogs = []                     # \"Original Cog positions\"  \n          \n        for i in range(0,self.numcogs):     # Create the cogs\n            self.cogs.append(Cog())\n            self.oCogs.append(self.cogs[i].shuf)  \n            \n        refabet = copy(num_alphabet) \n        self.reflector = copy(num_alphabet)  \n        while len(refabet) > 0:             # Pair letters in the reflector\n            a = choice(refabet)  \n            refabet.remove(a)  \n            \n            b = choice(refabet)  \n            refabet.remove(b)  \n            \n            self.reflector[a] = b  \n            self.reflector[b] = a\n            \n  \n    def print_setup(self): # Print out substituion setup.\n        print \"Enigma Setup:\\nCogs: \",self.numcogs,\"\\nCog arrangement:\"  \n        for i in range(0,self.numcogs):  \n            print self.cogs[i].shuf  \n        print \"Reflector arrangement:\\n\",self.reflector,\"\\n\"  \n          \n    def reset(self):  \n        for i in range(0,self.numcogs):  \n            self.cogs[i].setcog(self.oCogs[i])  \n              \n    def encode(self,text):  \n        t = 0     # Ticker counter  \n        ciphertext=\"\"  \n        for l in text.lower():  \n            num = ord(l) % 97  \n            # Handle special characters for readability\n            if (num>25 or num<0):  \n                if (self.readability):\n                    ciphertext += l   \n                else:  \n                    pass  \n            \n            else:\n                # Pass through cogs, reflect, then return through cogs\n                t += 1  \n                for i in range(self.numcogs): \n                    num = self.cogs[i].subs_in(num)  \n                      \n                num = self.reflector[num]  \n                  \n                for i in range(self.numcogs):  \n                    num = self.cogs[self.numcogs-i-1].subs_out(num)  \n                ciphertext += \"\" + chr(97+num)\n                  \n                # Rotate cogs\n                for i in range(self.numcogs):\n                    if ( t % ((i*6)+1) == 0 ):\n                        self.cogs[i].rotate()  \n        return ciphertext.upper()  "}
{"cell_type":"code","execution_count":9,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Original Message:\nWHEN PLACED IN AN ENIGMA, EACH ROTOR CAN BE SET TO ONE OF 26 POSSIBLE POSITIONS. WHEN INSERTED, IT CAN BE TURNED BY HAND USING THE GROOVED FINGER-WHEEL, WHICH PROTRUDES FROM THE INTERNAL ENIGMA COVER WHEN CLOSED. SO THAT THE OPERATOR CAN KNOW THE ROTOR'S POSITION, EACH HAD AN ALPHABET TYRE (OR LETTER RING) ATTACHED TO THE OUTSIDE OF THE ROTOR DISK, WITH 26 CHARACTERS (TYPICALLY LETTERS); ONE OF THESE COULD BE SEEN THROUGH THE WINDOW, THUS INDICATING THE ROTATIONAL POSITION OF THE ROTOR. IN EARLY MODELS, THE ALPHABET RING WAS FIXED TO THE ROTOR DISK. A LATER IMPROVEMENT WAS THE ABILITY TO ADJUST THE ALPHABET RING RELATIVE TO THE ROTOR DISK. THE POSITION OF THE RING WAS KNOWN AS THE RINGSTELLUNG (\"RING SETTING\"), AND WAS A PART OF THE INITIAL SETTING PRIOR TO AN OPERATING SESSION. IN MODERN TERMS IT WAS A PART OF THE INITIALIZATION VECTOR.\n\nEncrypted Message\nABFJ XHBSON NX KG IBHHOI, XGPW YDRMF ZEQ NR BUD EE FEY ZO 26 SRHOTNNR EDMAPYAZZ. OOLY SYUQIOBA, DF NDO OL EPCSQP VS FCEG PCKWN AMP MWGZEAZ XHQFFL-OWUAZ, AOOGC TGSPPBECE YJXD UAM ZEBGOQKO ZRKIXW GNSJG LQWC EAXUNM. PQ YDPD IGK GKMKBPSN NKR ZFIX EMK LBING'H EDZGWQVA, UKVZ XRK RY TWCZIAKN JTYT (EC XUFCOA WOHM) TVHQDELK XH YVB XPONQOK YD PEW YZBVZ EJYB, QZMJ 26 HQFYUFLJXZ (NZWZZLGEV UYUSTFM); QPV ZZ HPNJR FRSIW EL JLIT NWMABZQ VTS QRAOFL, NNEH LLVMJOCKWI XNN CHQDFHXWHU IHAOABWP UH HQB HVQDO. VV PGHEU HHOJBY, PAY GUFSXAPI QXIV PEL CGYGF PS SRZ IKRFP NGVJ. W BKMMC AVEPEKZEYIE FXV HBD NRCTQVE IS PAUAHC XOA CEXULGTQ CPQW MUMBFOXQ VC RUH ZGKUX HSKP. AVC GFIOMXQP MW NXP HMYO XSK FKWMB MR ZRU EUISVQCYPGJP (\"DYEH TFNETIK\"), UYO JLW H RXVA BZ DNI OHDNDIK PZXMQGY WBPAW OC FS KYLUFGLQY JWRYGPZ. OH GAQINS CCAIV NE FQA P DPXB MC ILB KIGJSKISEBIQNZ UZGUZS.\n\nDecrypted Message:\nWHEN PLACED IN AN ENIGMA, EACH ROTOR CAN BE SET TO ONE OF 26 POSSIBLE POSITIONS. WHEN INSERTED, IT CAN BE TURNED BY HAND USING THE GROOVED FINGER-WHEEL, WHICH PROTRUDES FROM THE INTERNAL ENIGMA COVER WHEN CLOSED. SO THAT THE OPERATOR CAN KNOW THE ROTOR'S POSITION, EACH HAD AN ALPHABET TYRE (OR LETTER RING) ATTACHED TO THE OUTSIDE OF THE ROTOR DISK, WITH 26 CHARACTERS (TYPICALLY LETTERS); ONE OF THESE COULD BE SEEN THROUGH THE WINDOW, THUS INDICATING THE ROTATIONAL POSITION OF THE ROTOR. IN EARLY MODELS, THE ALPHABET RING WAS FIXED TO THE ROTOR DISK. A LATER IMPROVEMENT WAS THE ABILITY TO ADJUST THE ALPHABET RING RELATIVE TO THE ROTOR DISK. THE POSITION OF THE RING WAS KNOWN AS THE RINGSTELLUNG (\"RING SETTING\"), AND WAS A PART OF THE INITIAL SETTING PRIOR TO AN OPERATING SESSION. IN MODERN TERMS IT WAS A PART OF THE INITIALIZATION VECTOR.\n"}],"source":"plaintext=\"\"\"When placed in an Enigma, each rotor can be set to one of 26 possible positions. \nWhen inserted, it can be turned by hand using the grooved finger-wheel, which protrudes from \nthe internal Enigma cover when closed. So that the operator can know the rotor's position, \neach had an alphabet tyre (or letter ring) attached to the outside of the rotor disk, with \n26 characters (typically letters); one of these could be seen through the window, thus indicating \nthe rotational position of the rotor. In early models, the alphabet ring was fixed to the rotor \ndisk. A later improvement was the ability to adjust the alphabet ring relative to the rotor disk. \nThe position of the ring was known as the Ringstellung (\"ring setting\"), and was a part of the \ninitial setting prior to an operating session. In modern terms it was a part of the \ninitialization vector.\"\"\"\n\n# Remove newlines for encryption\npt = \"\".join([l.upper() for l in plaintext if not l == \"\\n\"])\n# pt = \"\".join([l.upper() for l in plaintext if not l in punct])\n  \nx=Enigma(4)  \n#x.print_setup()  \n  \nprint \"Original Message:\"\nprint pt\n\nprint\nciphertext = x.encode(pt)  \nprint \"Encrypted Message\"\nprint ciphertext\n\nprint\n# Decryption and encryption are symmetric, so to decode we reset and re-encrypt.\nx.reset()  \ndecipheredtext = x.encode(ciphertext)  \nprint \"Decrypted Message:\"\nprint decipheredtext"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}