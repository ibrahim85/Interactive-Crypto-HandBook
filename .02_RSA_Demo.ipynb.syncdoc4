{"notebook_name":"02_RSA_Demo.ipynb"}
"## Public Key Cryptography\n\nThough RSA should be avoided for modern secure systems due to concerns with advancements in the discrete logarithm problem. We will still take a look at it.\n\nPublic key cryptography is a type of cryptography that simplifies the key exchange problem: there is no need for a secure channel to communicate keys over. Instead, each user generates a private key with an associated public key. The public key can be given out without any security risk. There is still the challenge of distributing and verifying public keys, but that is outside the scope of this document.\n\nLet's delve into RSA first:"︡{"metadata":{"collapsed":false,"trusted":false},"cell_type":"markdown"}
"import random\nimport math\n\nrandom.seed(1)\n# Function to test for composite. Return True for composite.\ndef _func_composite_test(a,d,n,s):\n    if pow( a, d, n ) == 1:\n        return False\n    for i in range(s):\n        if pow( a, 2**i * d, n ) == n-1:\n            return False\n    return True\n\n# Function to test for primality using Miller Rabin.\ndef _func_millerRabin_probable_prime(n):\n    assert n >= 2\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    # Write n-1 as 2**s * d\n    # Repeatedly try to divide n-1 by 2\n    s, d = 0, n-1\n    while True:\n        quotient, remainder = divmod(d, 2)\n        if remainder == 1:\n            break\n        s += 1\n        d = quotient\n    assert ( 2**s * d == n-1 )\n    # test the base a to see whether it is a witness for the compositeness of n\n    for i in range(0,10): # range is arbitrary...\n        a = random.randint( 2, n-1 )\n        if _func_composite_test(a,d,n,s):\n            return False\n    # Return True because n is not found to be a composite.\n    return True\n\n# Function to find a prime between a lower and an upper limit.\ndef find_prime( limit_lower, limit_upper ):\n    # Return a pseudo prime number roughly between a and b (can be larger than b).\n    # Raise ValueError if cannot find a pseudo prime after 10 * ln(x) + 3 tries.\n    x = random.randint(limit_lower, limit_upper)\n    for i in range( 0, int(10 * math.log(x) + 3) ):\n        if _func_millerRabin_probable_prime(x):\n            return x\n        else:\n            x += 1\n    raise ValueError\n\n# Create a prime and show it.\nprint 'Prime p: ', find_prime( limit_lower=10**12, limit_upper=10**13 )\nprint 'Prime q: ', find_prime( limit_lower=10**12, limit_upper=10**13 )"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":1,"outputs":[{"output_type":"stream","text":"Prime p:  2209278197029\nPrime q:  1229012748941\n","name":"stdout"}]}
"We now have two prime numbers and we will use these to generate a large co-prime N. \n\n$N=p∗q$\n\nThe amazing thing about these co-primes is that their factors are p and q. No other integers form the factors of this large co-prime. Since the **factorization** of large numbers is a mathematically hard problem (One-way trapdoor function) this gives us a perfect number that is easy to calculate when you know _p_ and _q_, but very hard to work back from when you only know _N_ and not know _p_ and _q_. "︡{"metadata":{},"cell_type":"markdown"}
"p = 2209278197029 \nq = 1229012748941\nN = p * q\nprint 'N: ', N"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":2,"outputs":[{"output_type":"stream","text":"N:  2715231070106027509096289\n","name":"stdout"}]}
"The main idea behind RSA is that we want to have both a part of the key that is public (i.e., everybody can know that part/those parts) and a part that is private (i.e., only we know that part).\nIn order to achieve this we are going to use another piece of mathematics that is also very easy to calculate but very hard to undo: Modular Arithmetics."︡{"metadata":{},"cell_type":"markdown"}
"phi_N = N - p - q + 1\nprint 'Phi of N:   ', phi_N\nprint 'Difference: ', N - phi_N"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":3,"outputs":[{"output_type":"stream","text":"Phi of N:    2715231070102589218150320\nDifference:  3438290945969\n","name":"stdout"}]}
"We now need to select two integers _e_ and _d_ \nIt is standard practice to select _e = 65537 when N - p - q + 1 > 65537_. We can then select d accordingly. "︡{"metadata":{},"cell_type":"markdown"}
"# Function to get d from e and phi(N)\ndef fn_rsa_get_d( e, phi ):\n    N_phi = phi\n    x = lasty = 0\n    lastx = y = 1\n    while phi != 0:\n        q = e // phi\n        e, phi = phi, e % phi\n        x, lastx = lastx - q*x, x\n        y, lasty = lasty - q*y, y\n    if lastx < 0:\n        lastx += N_phi\n    return lastx\n\n# Lets try this\ne = 65537\nd = fn_rsa_get_d( e=e, phi=phi_N )\nprint 'prime p:    ', p\nprint 'prime q:    ', q\nprint 'co-prime N: ', N\nprint 'Phi of N:   ', phi_N\nprint 'e:          ', e\nprint 'd:          ', d"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":4,"outputs":[{"output_type":"stream","text":"prime p:     2209278197029\nprime q:     1229012748941\nco-prime N:  2715231070106027509096289\nPhi of N:    2715231070102589218150320\ne:           65537\nd:           1662689065800343477772993\n","name":"stdout"}]}
"mp = 2328\nmc = pow( mp,e,N )\nmd = pow( mc,d,N )\nprint 'message: ', mp\nprint 'cipher:  ', mc\nprint 'decrypt: ', md"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":5,"outputs":[{"output_type":"stream","text":"message:  2328\ncipher:   993844035141996221196954\ndecrypt:  2328\n","name":"stdout"}]}
"Now Let's look at how to use pycrypto to do this, it is easy to generate a private/public key pair with pycrypto. We need to specify the size of the key in bits: we picked 1024 bits. Larger is more secure. We also need to specify a random number generator function, we use the Random module of pycrypto for that."︡{"metadata":{},"cell_type":"markdown"}
"from Crypto.PublicKey import RSA\nfrom Crypto import Random\nrandom_generator = Random.new().read\nkey = RSA.generate(1024, random_generator)\nkey"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":11,"outputs":[{"output_type":"execute_result","data":{"text/plain":"<_RSAobj @0x7fa105ffcd40 n(1024),e,d,p,q,u,private>"},"metadata":{},"execution_count":11}]}
"Now that we have our key pair, we can encrypt some data. First, we extract the public key from the key pair and use it to encrypt some data. 32 is a random parameter used by the RSA algorithm to encrypt the data. This step simulates us publishing the encryption key and someone using it to encrypt some data before sending it to us."︡{"metadata":{},"cell_type":"markdown"}
"public_key = key.publickey()\nenc_data = public_key.encrypt(r'abcdefgh', 32)\nenc_data"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":16,"outputs":[{"output_type":"execute_result","data":{"text/plain":"('\\r\\xd3\\xbby\\x87\\x1d\\xd0K9\\x08\\x8f\\x81N\\xa7\\x02\\xfath\\xf4BH\\x82\\xc7\\xc9w\\xe3\\x96T+\\x00\\x95\\x8ce\\xc8\\x0b+\\x12\\x81\\xc3\\xba\\x90\\'\\xb3\\xd8\\xa2\\xb6`\\x9b~v|t\\xdb+\\xcfx\\x96\\x92\\xc4\\xfa\\x7f\\x93v]q\\xf5\\xc3\\\\RB\\xbe\\xff\\xb8\\xc5\\x90\\x89\\xe8MUi\\xa7\\xc4\\xd6\\xc8\\x10\\xda\\xc7hk_\\xe0\\x82\\xbb\\xdb\\xc7\\xb5\\xce\\xac65\\x15\\xa2\\xdd2m?\\x98Y\"\\xa9\\xbdn0\\xdd\\x8b\\xfb\\xa5\\xb9t\\xb6\\xea.H+\\x8c\\xf6\\xd3\\x90',)"},"metadata":{},"execution_count":16}]}
"key.decrypt(enc_data)"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":17,"outputs":[{"output_type":"execute_result","data":{"text/plain":"'abcdefgh'"},"metadata":{},"execution_count":17}]}
"from Crypto.Hash import SHA256\nfrom Crypto.PublicKey import RSA\nfrom Crypto import Random\nkey = RSA.generate(1024, random_generator)\ntext = r'abcdefgh'\nhash = SHA256.new(text).digest()\nsignature = key.sign(hash, '')"︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"code","execution_count":18,"outputs":[]}
"text = r'abcdefgh'\nhash = SHA256.new(text).digest()\npublic_key.verify(hash, signature)"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":19,"outputs":[{"output_type":"execute_result","data":{"text/plain":"False"},"metadata":{},"execution_count":19}]}
"From http://coding4streetcred.com/blog/post/Asymmetric-Encryption-Revisited-(in-PyCrypto)"︡{"metadata":{},"cell_type":"markdown"}
"import Crypto\nfrom Crypto.PublicKey import RSA\nfrom Crypto import Random\nfrom Crypto.Hash import MD5\n \n# Use a larger key length in practice...\nKEY_LENGTH = 1024  # Key size (in bits)\nrandom_gen = Random.new().read\n \n# Generate RSA private/public key pairs for both parties...\nkeypair_snowden = RSA.generate(KEY_LENGTH, random_gen)\nkeypair_pytn    = RSA.generate(KEY_LENGTH, random_gen)\n \n# Public key export for exchange between parties...\npubkey_snowden  = keypair_snowden.publickey()\npubkey_pytn     = keypair_pytn.publickey()\n \n# Plain text messages...\nmessage_to_snowden  = 'You are a patriot!'\nmessage_to_pytn     = \"Russia is really nice this time of year...\\nUse encryption and make the NSA CPUs churn and burn!\"\n \n# Generate digital signatures using private keys...\nhash_of_snowden_message = SHA256.new(message_to_snowden).digest()\nsignature_pytn          = keypair_pytn.sign(hash_of_snowden_message, '')\nhash_of_pytn_message    = SHA256.new(message_to_pytn).digest()\nsignature_snowden       = keypair_snowden.sign(hash_of_pytn_message, '')\n \n# Encrypt messages using the other party's public key...\nencrypted_for_snowden   = pubkey_snowden.encrypt(message_to_snowden, 32)    #from PyTN\nencrypted_for_pytn      = pubkey_pytn.encrypt(message_to_pytn, 32)          #from Snowden\n \n# Decrypt messages using own private keys...\ndecrypted_snowden   = keypair_snowden.decrypt(encrypted_for_snowden)\ndecrypted_pytn      = keypair_pytn.decrypt(encrypted_for_pytn)\n \n# Signature validation and console output...\nhash_snowden_decrypted = SHA256.new(decrypted_snowden).digest()\nif pubkey_pytn.verify(hash_snowden_decrypted, signature_pytn):\n    print \"Edward Snowden received from PyTn:\"\n    print decrypted_snowden\n    print \"\"\n \nhash_pytn_decrypted = SHA256.new(decrypted_pytn).digest()\nif pubkey_snowden.verify(hash_pytn_decrypted, signature_snowden):\n   print \"PyTN received from Edward Snowden:\"\n   print decrypted_pytn"︡{"metadata":{"trusted":true,"collapsed":false},"cell_type":"code","execution_count":20,"outputs":[{"output_type":"stream","text":"Edward Snowden received from PyTn:\nYou are a patriot!\n\nPyTN received from Edward Snowden:\nRussia is really nice this time of year...\nUse encryption and make the NSA CPUs churn and burn!\n","name":"stdout"}]}
""︡{"metadata":{"trusted":true,"collapsed":true},"cell_type":"code","execution_count":null,"outputs":[]}