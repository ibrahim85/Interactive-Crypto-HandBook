"{\"notebook_name\":\"BitVector_use.ipynb\"}\n\"\"︡{\"metadata\":{\"collapsed\":false,\"trusted\":true},\"cell_type\":\"code\",\"execution_count\":3,\"outputs\":[{\"output_type\":\"error\",\"ename\":\"SyntaxError\",\"evalue\":\"invalid syntax (<ipython-input-3-4ec39b98fe68>, line 1)\",\"traceback\":[\"\\u001b[1;36m  File \\u001b[1;32m\\\"<ipython-input-3-4ec39b98fe68>\\\"\\u001b[1;36m, line \\u001b[1;32m1\\u001b[0m\\n\\u001b[1;33m    EncryptForFun.py  message_file.txt  output.txt\\u001b[0m\\n\\u001b[1;37m                                 ^\\u001b[0m\\n\\u001b[1;31mSyntaxError\\u001b[0m\\u001b[1;31m:\\u001b[0m invalid syntax\\n\"]}]}\n\"\"︡{\"metadata\":{\"trusted\":true,\"collapsed\":true},\"cell_type\":\"code\",\"execution_count\":null,\"outputs\":[]}"
{"patch":[[[[0,"pynb\"}\n\""],[1,"EncryptForFun.py  message_file.txt  output.txt"],[0,"\"︡{\"meta"]],33,33,16,62]],"time":1456666156744}
{"patch":[[[[0,"_count\":"],[-1,"3"],[1,"2"],[0,",\"output"]],165,165,17,17],[[[0,"ame\":\"Sy"],[-1,"ntaxError"],[1,"stemExit"],[0,"\",\"evalu"]],212,212,25,24],[[[0,"e\":\""],[-1,"invalid syntax (<ipython-input-3-4ec39b98fe68>, line 1)\",\"traceback\":[\"\\u001b[1;36m  File \\u001b[1;32m\\\"<ipython-input-3-4ec39b98fe68>\\\"\\u001b[1;36m, line "],[1,"Needs two command-line arguments, one for the message file and the other for the encrypted output file\",\"traceback\":[\"An exception has occurred, use %tb to see the full traceback.\\n\",\"\\u001b[1;31mSystemExit"],[0,"\\u001b["],[-1,"1;32m1"],[1,"0m"],[0,"\\u001b["],[-1,"0m\\n"],[1,"1;31m:"],[0,"\\u001b["],[-1,"1;33m    EncryptForFun.py "],[1,"0m Needs two command-line arguments, one for the"],[0," message"],[-1,"_"],[1," "],[0,"file"],[-1,".txt  output.txt\\u001b[0m\\n\\u001b[1;37m                                 ^\\u001b[0m\\n\\u001b[1;31mSyntaxError\\u001b[0m\\u001b[1;31m:\\u001b[0m invalid syntax\\n\"]"],[1," and the other for the encrypted output file\\n\"]},{\"output_type\":\"stream\",\"text\":\"To exit: use 'exit', 'quit', or Ctrl-D.\\n\",\"name\":\"stderr\""],[0,"}]}\n"]],236,236,390,444]],"time":1456666134832}
{"patch":[[[[0,"\"}\n\""],[-1,"EncryptForFun.py  message_file.txt  output.txt"],[0,"\"︡{\""]],37,37,54,8]],"time":1456666124786}
{"patch":[[[[0,"pynb\"}\n\""],[1,"#!/usr/bin/env python\\n\\n###  EncryptForFun.py\\n###  Avi Kak  (kak@purdue.edu)\\n###  January 21, 2014, modified January 11, 2016\\n\\n###  Medium strength encryption/decryption for secure message exchange\\n###  for fun.\\n\\n###  Based on differential XORing of bit blocks.  Differential XORing\\n###  destroys any repetitive patterns in the messages to be encrypted and\\n###  makes it more difficult to break encryption by statistical\\n###  analysis. Differential XORing needs an Initialization Vector that is\\n###  derived from a pass phrase in the script shown below.  The security\\n###  level of this script can be taken to full strength by using 3DES or\\n###  AES for encrypting the bit blocks produced by differential XORing.\\n\\n###  Call syntax:\\n###\\n###       EncryptForFun.py  message_file.txt  output.txt\\n###\\n###  The encrypted output is deposited in the file `output.txt'\\n\\nimport sys\\nfrom BitVector import *                                                       #(A)\\n\\nif len(sys.argv) is not 3:                                                    #(B)\\n    sys.exit('''Needs two command-line arguments, one for '''\\n             '''the message file and the other for the '''\\n             '''encrypted output file''')\\n\\nPassPhrase = \\\"Hopes and dreams of a million years\\\"                            #(C)\\n\\nBLOCKSIZE = 64                                                                #(D)\\nnumbytes = BLOCKSIZE // 8                                                     #(E)\\n\\n# Reduce the passphrase to a bit array of size BLOCKSIZE:\\nbv_iv = BitVector(bitlist = [0]*BLOCKSIZE)                                    #(F)\\nfor i in range(0,len(PassPhrase) // numbytes):                                #(G)\\n    textstr = PassPhrase[i*numbytes:(i+1)*numbytes]                           #(H)\\n    bv_iv ^= BitVector( textstring = textstr )                                #(I)\\n\\n# Get key from user:\\nkey = None\\nif sys.version_info[0] == 3:                                                  #(J)\\n    key = input(\\\"\\\\nEnter key: \\\")                                              #(K)\\nelse:                                                                         \\n    key = raw_input(\\\"\\\\nEnter key: \\\")                                          #(L)\\nkey = key.strip()                                                             #(M)\\n\\n# Reduce the key to a bit array of size BLOCKSIZE:\\nkey_bv = BitVector(bitlist = [0]*BLOCKSIZE)                                   #(N)\\nfor i in range(0,len(key) // numbytes):                                       #(O)\\n    keyblock = key[i*numbytes:(i+1)*numbytes]                                 #(P)\\n    key_bv ^= BitVector( textstring = keyblock )                              #(Q)\\n\\n# Create a bitvector for storing the ciphertext bit array:\\nmsg_encrypted_bv = BitVector( size = 0 )                                      #(R)\\n\\n# Carry out differential XORing of bit blocks and encryption:\\nprevious_block = bv_iv                                                        #(S)\\nbv = BitVector( filename = sys.argv[1] )                                      #(T)\\nwhile (bv.more_to_read):                                                      #(U)\\n    bv_read = bv.read_bits_from_file(BLOCKSIZE)                               #(V)\\n    if len(bv_read) < BLOCKSIZE:                                              #(W)\\n        bv_read += BitVector(size = (BLOCKSIZE - len(bv_read)))               #(X)\\n    bv_read ^= key_bv                                                         #(Y)\\n    bv_read ^= previous_block                                                 #(Z)\\n    previous_block = bv_read.deep_copy()                                      #(a)\\n    msg_encrypted_bv += bv_read                                               #(b)\\n\\n# Convert the encrypted bitvector into a hex string:    \\noutputhex = msg_encrypted_bv.get_hex_string_from_bitvector()                  #(c)\\n\\n# Write ciphertext bitvector to the output file:\\nFILEOUT = open(sys.argv[2], 'w')                                              #(d)\\nFILEOUT.write(outputhex)                                                      #(e)\\nFILEOUT.close()                                                               #(f)\\n"],[0,"\"︡{\"meta"]],33,33,16,4250]],"time":1456666082759}
{"patch":[[[[0,"_count\":"],[-1,"2"],[1,"1"],[0,",\"output"]],4353,4353,17,17],[[[0,"ename\":\""],[-1,"SystemExit"],[1,"ImportError"],[0,"\",\"evalu"]],4398,4398,26,27],[[[0,"\":\"N"],[-1,"eeds two command-line arguments, one for the message file and the other for the encrypted output file\",\"traceback\":[\"An exception has occurred, use %tb to see the full traceback.\\n\",\"\\u001b[1;31mSystemExit\\u001b[0m\\u001b[1;31m:\\u001b[0m Needs two command-line arguments, one for the message file and the other for the encrypted output file\\n\"]},{\"output_type\":\"stream\",\"text\":\"To exit: use 'exit', 'quit', or Ctrl-D.\\n\",\"name\":\"stder"],[1,"o module named BitVector\",\"traceback\":[\"\\u001b[1;31m---------------------------------------------------------------------------\\u001b[0m\",\"\\u001b[1;31mImportError\\u001b[0m                               Traceback (most recent call last)\",\"\\u001b[1;32m<ipython-input-1-6facd3639ed3>\\u001b[0m in \\u001b[0;36m<module>\\u001b[1;34m()\\u001b[0m\\n\\u001b[0;32m     18\\u001b[0m \\u001b[1;33m\\u001b[0m\\u001b[0m\\n\\u001b[0;32m     19\\u001b[0m \\u001b[1;32mimport\\u001b[0m \\u001b[0msys\\u001b[0m\\u001b[1;33m\\u001b[0m\\u001b[0m\\n\\u001b[1;32m---> 20\\u001b[1;33m \\u001b[1;32mfrom\\u001b[0m \\u001b[0mBitVector\\u001b[0m \\u001b[1;32mimport\\u001b[0m \\u001b[1;33m*\\u001b[0m\\u001b[1;33m\\u001b[0m\\u001b[0m\\n\\u001b[0m\\u001b[0;32m     21\\u001b[0m \\u001b[1;33m\\u001b[0m\\u001b[0m\\n\\u001b[0;32m     22\\u001b[0m \\u001b[1;32mif\\u001b[0m \\u001b[0mlen\\u001b[0m\\u001b[1;33m(\\u001b[0m\\u001b[0msys\\u001b[0m\\u001b[1;33m.\\u001b[0m\\u001b[0margv\\u001b[0m\\u001b[1;33m)\\u001b[0m \\u001b[1;32mis\\u001b[0m \\u001b[1;32mnot\\u001b[0m \\u001b[1;36m3\\u001b[0m\\u001b[1;33m:\\u001b[0m\\u001b[1;33m\\u001b[0m\\u001b[0m\\n\",\"\\u001b[1;31mImportError\\u001b[0m: No module named BitVecto"],[0,"r\""],[1,"]"],[0,"}]}\n"]],4426,4426,443,1128]],"time":1456666036937}
{"patch":[[[[0,"\"}\n\""],[-1,"#!/usr/bin/env python\\n\\n###  EncryptForFun.py\\n###  Avi Kak  (kak@purdue.edu)\\n###  January 21, 2014, modified January 11, 2016\\n\\n###  Medium strength encryption/decryption for secure message exchange\\n###  for fun.\\n\\n###  Based on differential XORing of bit blocks.  Differential XORing\\n###  destroys any repetitive patterns in the messages to be encrypted and\\n###  makes it more difficult to break encryption by statistical\\n###  analysis. Differential XORing needs an Initialization Vector that is\\n###  derived from a pass phrase in the script shown below.  The security\\n###  level of this script can be taken to full strength by using 3DES or\\n###  AES for encrypting the bit blocks produced by differential XORing.\\n\\n###  Call syntax:\\n###\\n###       EncryptForFun.py  message_file.txt  output.txt\\n###\\n###  The encrypted output is deposited in the file `output.txt'\\n\\nimport sys\\nfrom BitVector import *                                                       #(A)\\n\\nif len(sys.argv) is not 3:                                                    #(B)\\n    sys.exit('''Needs two command-line arguments, one for '''\\n             '''the message file and the other for the '''\\n             '''encrypted output file''')\\n\\nPassPhrase = \\\"Hopes and dreams of a million years\\\"                            #(C)\\n\\nBLOCKSIZE = 64                                                                #(D)\\nnumbytes = BLOCKSIZE // 8                                                     #(E)\\n\\n# Reduce the passphrase to a bit array of size BLOCKSIZE:\\nbv_iv = BitVector(bitlist = [0]*BLOCKSIZE)                                    #(F)\\nfor i in range(0,len(PassPhrase) // numbytes):                                #(G)\\n    textstr = PassPhrase[i*numbytes:(i+1)*numbytes]                           #(H)\\n    bv_iv ^= BitVector( textstring = textstr )                                #(I)\\n\\n# Get key from user:\\nkey = None\\nif sys.version_info[0] == 3:                                                  #(J)\\n    key = input(\\\"\\\\nEnter key: \\\")                                              #(K)\\nelse:                                                                         \\n    key = raw_input(\\\"\\\\nEnter key: \\\")                                          #(L)\\nkey = key.strip()                                                             #(M)\\n\\n# Reduce the key to a bit array of size BLOCKSIZE:\\nkey_bv = BitVector(bitlist = [0]*BLOCKSIZE)                                   #(N)\\nfor i in range(0,len(key) // numbytes):                                       #(O)\\n    keyblock = key[i*numbytes:(i+1)*numbytes]                                 #(P)\\n    key_bv ^= BitVector( textstring = keyblock )                              #(Q)\\n\\n# Create a bitvector for storing the ciphertext bit array:\\nmsg_encrypted_bv = BitVector( size = 0 )                                      #(R)\\n\\n# Carry out differential XORing of bit blocks and encryption:\\nprevious_block = bv_iv                                                        #(S)\\nbv = BitVector( filename = sys.argv[1] )                                      #(T)\\nwhile (bv.more_to_read):                                                      #(U)\\n    bv_read = bv.read_bits_from_file(BLOCKSIZE)                               #(V)\\n    if len(bv_read) < BLOCKSIZE:                                              #(W)\\n        bv_read += BitVector(size = (BLOCKSIZE - len(bv_read)))               #(X)\\n    bv_read ^= key_bv                                                         #(Y)\\n    bv_read ^= previous_block                                                 #(Z)\\n    previous_block = bv_read.deep_copy()                                      #(a)\\n    msg_encrypted_bv += bv_read                                               #(b)\\n\\n# Convert the encrypted bitvector into a hex string:    \\noutputhex = msg_encrypted_bv.get_hex_string_from_bitvector()                  #(c)\\n\\n# Write ciphertext bitvector to the output file:\\nFILEOUT = open(sys.argv[2], 'w')                                              #(d)\\nFILEOUT.write(outputhex)                                                      #(e)\\nFILEOUT.close()                                                               #(f)\\n"],[0,"\"︡{\""]],37,37,4242,8]],"time":1456666032755}
{"patch":[[[[0,"pynb\"}\n\""],[1,"#!/usr/bin/env python\\n\\n###  EncryptForFun.py\\n\\n###  Based on differential XORing of bit blocks.  Differential XORing\\n###  destroys any repetitive patterns in the messages to be encrypted and\\n###  makes it more difficult to break encryption by statistical\\n###  analysis. Differential XORing needs an Initialization Vector that is\\n###  derived from a pass phrase in the script shown below.  The security\\n###  level of this script can be taken to full strength by using 3DES or\\n###  AES for encrypting the bit blocks produced by differential XORing.\\n\\n###  Call syntax:\\n###\\n###       EncryptForFun.py  message_file.txt  output.txt\\n###\\n###  The encrypted output is deposited in the file `output.txt'\\n\\nimport sys\\nfrom BitVector import *                                                      \\n\\nif len(sys.argv) is not 3:                                                   \\n    sys.exit('''Needs two command-line arguments, one for '''\\n             '''the message file and the other for the '''\\n             '''encrypted output file''')\\n\\nPassPhrase = \\\"NCTU SI2 STAR XD\\\"                            #(C)\\n\\nBLOCKSIZE = 64                                                               \\nnumbytes = BLOCKSIZE // 8                                                    \\n\\n# Reduce the passphrase to a bit array of size BLOCKSIZE:\\nbv_iv = BitVector(bitlist = [0]*BLOCKSIZE)                                   \\nfor i in range(0,len(PassPhrase) // numbytes):                               \\n    textstr = PassPhrase[i*numbytes:(i+1)*numbytes]                          \\n    bv_iv ^= BitVector( textstring = textstr )                               \\n\\n# Get key from user:\\nkey = None\\nif sys.version_info[0] == 3:                                                 \\n    key = input(\\\"\\\\nEnter key: \\\")                                             \\nelse:                                                                        \\n    key = raw_input(\\\"\\\\nEnter key: \\\")                                         \\nkey = key.strip()                                                            \\n\\n# Reduce the key to a bit array of size BLOCKSIZE:\\nkey_bv = BitVector(bitlist = [0]*BLOCKSIZE)                                  \\nfor i in range(0,len(key) // numbytes):                                      \\n    keyblock = key[i*numbytes:(i+1)*numbytes]                                \\n    key_bv ^= BitVector( textstring = keyblock )                             \\n\\n# Create a bitvector for storing the ciphertext bit array:\\nmsg_encrypted_bv = BitVector( size = 0 )                                     \\n\\n# Carry out differential XORing of bit blocks and encryption:\\nprevious_block = bv_iv                                                       \\nbv = BitVector( filename = sys.argv[1] )                                     \\nwhile (bv.more_to_read):                                                     \\n    bv_read = bv.read_bits_from_file(BLOCKSIZE)                              \\n    if len(bv_read) < BLOCKSIZE:                                             \\n        bv_read += BitVector(size = (BLOCKSIZE - len(bv_read)))              \\n    bv_read ^= key_bv                                                        \\n    bv_read ^= previous_block                                                \\n    previous_block = bv_read.deep_copy()                                     \\n    msg_encrypted_bv += bv_read                                              \\n\\n# Convert the encrypted bitvector into a hex string:    \\noutputhex = msg_encrypted_bv.get_hex_string_from_bitvector()                 \\n\\n# Write ciphertext bitvector to the output file:\\nFILEOUT = open(sys.argv[2], 'w')                                             \\nFILEOUT.write(outputhex)                                                     \\nFILEOUT.close()                                                              \\n"],[0,"\"︡{\"meta"]],33,33,16,3904]],"time":1456665360710}
{"patch":[[[[0,"nt\":"],[-1,"1,\"outputs\":[{\"output_type\":\"error\",\"ename\":\"ImportError\",\"evalue\":\"No module named BitVector\",\"traceback\":[\"\\u001b[1;31m---------------------------------------------------------------------------\\u001b[0m\",\"\\u001b[1;31mImportError\\u001b[0m                               Traceback (most recent call last)\",\"\\u001b[1;32m<ipython-input-1-6facd3639ed3>\\u001b[0m in \\u001b[0;36m<module>\\u001b[1;34m()\\u001b[0m\\n\\u001b[0;32m     18\\u001b[0m \\u001b[1;33m\\u001b[0m\\u001b[0m\\n\\u001b[0;32m     19\\u001b[0m \\u001b[1;32mimport\\u001b[0m \\u001b[0msys\\u001b[0m\\u001b[1;33m\\u001b[0m\\u001b[0m\\n\\u001b[1;32m---> 20\\u001b[1;33m \\u001b[1;32mfrom\\u001b[0m \\u001b[0mBitVector\\u001b[0m \\u001b[1;32mimport\\u001b[0m \\u001b[1;33m*\\u001b[0m\\u001b[1;33m\\u001b[0m\\u001b[0m\\n\\u001b[0m\\u001b[0;32m     21\\u001b[0m \\u001b[1;33m\\u001b[0m\\u001b[0m\\n\\u001b[0;32m     22\\u001b[0m \\u001b[1;32mif\\u001b[0m \\u001b[0mlen\\u001b[0m\\u001b[1;33m(\\u001b[0m\\u001b[0msys\\u001b[0m\\u001b[1;33m.\\u001b[0m\\u001b[0margv\\u001b[0m\\u001b[1;33m)\\u001b[0m \\u001b[1;32mis\\u001b[0m \\u001b[1;32mnot\\u001b[0m \\u001b[1;36m3\\u001b[0m\\u001b[1;33m:\\u001b[0m\\u001b[1;33m\\u001b[0m\\u001b[0m\\n\",\"\\u001b[1;31mImportError\\u001b[0m: No module named BitVector\"]}"],[1,"null,\"outputs\":["],[0,"]}\n\""]],4011,4011,1198,24]],"time":1456665352715}
{"patch":[[[[0,"ed\":"],[-1,"true},\"cell_type\":\"code\",\"execution_count\":null,\"outputs\":[]}\n\"\"︡{\"metadata\":{\"trusted\":true,\"collapsed\":tru"],[1,"fals"],[0,"e},\""]],3968,3968,116,12]],"time":1456665348713}
{"patch":[[[[0,"            "],[1," #(B)"],[0,"\\n    sys.ex"]],912,912,24,29],[[[0,"        "],[1," #(D)"],[0,"\\nnumbyt"]],1237,1237,16,21],[[[0,"                "],[1," #(E)"],[0,"\\n\\n# Reduce the"]],1313,1313,32,37],[[[0,"                "],[1," #(F)"],[0,"\\nfor i in range"]],1458,1458,32,37],[[[0,"            "],[1," #(G)"],[0,"\\n    textst"]],1546,1546,24,29],[[[0,"                "],[1," #(H)"],[0,"\\n    bv_iv ^= B"]],1626,1626,32,37],[[[0,"            "],[1," #(I)"],[0,"\\n\\n# Get ke"]],1714,1714,24,29],[[[0,"                "],[1," #(J)"],[0,"\\n    key = inpu"]],1830,1830,32,37],[[[0,"    "],[1," #(K)"],[0,"\\nelse:"],[1," "],[0,"    "]],1929,1929,15,21],[[[0,"        "],[1," #(L)"],[0,"\\nkey = "]],2092,2092,16,21],[[[0,"            "],[1," #(M)"],[0,"\\n\\n# Reduce"]],2172,2172,24,29],[[[0,"        "],[1," "],[1,"#(N)"],[0,"\\nfor i "]],2314,2314,16,21],[[[0,"                "],[1," #(O)"],[0,"\\n    keyblock ="]],2390,2390,32,37],[[[0,"                "],[1," "],[1,"#(P)"],[0,"\\n    key_bv ^= "]],2474,2474,32,37],[[[0,"            "],[1," #(Q)"],[0,"\\n\\n# Create"]],2562,2562,24,29],[[[0,"            "],[1," #(R)"],[0,"\\n\\n# Carry "]],2708,2708,24,29],[[[0,"        "],[1," #(S)"],[0,"\\nbv = B"]],2861,2861,16,21],[[[0,"        "],[1," #(T)"],[0,"\\nwhile "]],2945,2945,16,21],[[[0,"                "],[1," #(U)"],[0,"\\n    bv_read = "]],3021,3021,32,37],[[[0,"            "],[1," #(V)"],[0,"\\n    if len"]],3109,3109,24,29],[[[0,"            "],[1," #(W)"],[0,"\\n        bv"]],3193,3193,24,29],[[[0,"))              "],[1," #(X)"],[0,"\\n    bv_read ^="]],3273,3273,32,37],[[[0,"            "],[1," #(Y)"],[0,"\\n    bv_rea"]],3361,3361,24,29],[[[0,"            "],[1," #(Z)"],[0,"\\n    previo"]],3445,3445,24,29],[[[0,"            "],[1," #(a)"],[0,"\\n    msg_en"]],3529,3529,24,29],[[[0,"            "],[1," #(b)"],[0,"\\n\\n# Conver"]],3613,3613,24,29],[[[0,"            "],[1," #(c)"],[0,"\\n\\n# Write "]],3757,3757,24,29],[[[0,"                "],[1," #(d)"],[0,"\\nFILEOUT.write("]],3889,3889,32,37],[[[0,"        "],[1," "],[1,"#(e)"],[0,"\\nFILEOU"]],3981,3981,16,21],[[[0,"        "],[1," #(f)"],[0,"\\n\"︡{\"me"]],4065,4065,16,21]],"time":1456665134727}
{"patch":[[[[0,"        "],[1," #(A)"],[0,"\\n\\nif l"]],835,835,16,21]],"time":1456665128716}
{"patch":[[[[0,"TAR "],[-1,"XD"],[0,"\\\"  "]],1129,1129,10,8]],"time":1456665063714}
{"patch":[[[[0,"SI2 "],[-1,"STAR "],[0,"\\\"  "]],1124,1124,13,8]],"time":1456665059716}
{"patch":[[[[0,"CTU "],[-1,"SI2 "],[1,"GOGO GO"],[0,"\\\"  "]],1120,1120,12,15]],"time":1456665055718}
{"patch":[[[[0,"TU G"],[-1,"OGO GO"],[0,"\\\"  "]],1121,1121,14,8]],"time":1456665051715}
{"patch":[[[[0,"= \\\""],[-1,"NCTU G"],[1,"I"],[0,"\\\"  "]],1115,1115,14,9]],"time":1456665047715}
{"patch":[[[[0,"ase = \\\""],[-1,"I"],[1,"Hopes and dreams of a million years"],[0,"\\\"      "]],1111,1111,17,51]],"time":1456665043719}
{"patch":[[[[0,"orFun.py\\n\\n"],[1,"\\n"],[0,"###  Based o"]],79,79,24,26]],"time":1456664990718}
{"patch":[[[[0,"n\\n\\n###"],[1,"  Medium strength encryption/decryption for secure message exchange\\n###  for fun.\\n\\n###"],[0,"  Based "]],88,88,16,105]],"time":1456664986722}
{"patch":[[[[0,"Fun.py\\n"],[1,"###  Avi Kak  (kak@purdue.edu)\\n###  January 21, 2014, modified January 11, 2016"],[0,"\\n\\n### "]],81,81,16,96]],"time":1456664982722}
{"patch":[[[[-1,"{\"notebook_name\":\"BitVector_use.ipynb\"}\n\"#!/usr/bin/env python\\n\\n###  EncryptForFun.py\\n###  Avi Kak  (kak@purdue.edu)\\n###  January 21, 2014, modified January 11, 2016\\n\\n###  Medium strength encryption/decryption for secure message exchange\\n###  for fun.\\n\\n###  Based on differential XORing of bit blocks.  Differential XORing\\n###  destroys any repetitive patterns in the messages to be encrypted and\\n###  makes it more difficult to break encryption by statistical\\n###  analysis. Differential XORing needs an Initialization Vector that is\\n###  derived from a pass phrase in the script shown below.  The security\\n###  level of this script can be taken to full strength by using 3DES or\\n###  AES for encrypting the bit blocks produced by differential XORing.\\n\\n###  Call syntax:\\n###\\n###       EncryptForFun.py  message_file.txt  output.txt\\n###\\n###  The encrypted output is deposited in the file `output.txt'\\n\\nimport sys\\nfrom BitVector import *                                                       #(A)\\n\\nif len(sys.argv) is not 3:                                                    #(B)\\n    sys.exit('''Needs two command-line arguments, one for '''\\n             '''the message file and the other for the '''\\n             '''encrypted output file''')\\n\\nPassPhrase = \\\"Hopes and dreams of a million years\\\"                            #(C)\\n\\nBLOCKSIZE = 64                                                                #(D)\\nnumbytes = BLOCKSIZE // 8                                                     #(E)\\n\\n# Reduce the passphrase to a bit array of size BLOCKSIZE:\\nbv_iv = BitVector(bitlist = [0]*BLOCKSIZE)                                    #(F)\\nfor i in range(0,len(PassPhrase) // numbytes):                                #(G)\\n    textstr = PassPhrase[i*numbytes:(i+1)*numbytes]                           #(H)\\n    bv_iv ^= BitVector( textstring = textstr )                                #(I)\\n\\n# Get key from user:\\nkey = None\\nif sys.version_info[0] == 3:                                                  #(J)\\n    key = input(\\\"\\\\nEnter key: \\\")                                              #(K)\\nelse:                                                                         \\n    key = raw_input(\\\"\\\\nEnter key: \\\")                                          #(L)\\nkey = key.strip()                                                             #(M)\\n\\n# Reduce the key to a bit array of size BLOCKSIZE:\\nkey_bv = BitVector(bitlist = [0]*BLOCKSIZE)                                   #(N)\\nfor i in range(0,len(key) // numbytes):                                       #(O)\\n    keyblock = key[i*numbytes:(i+1)*numbytes]                                 #(P)\\n    key_bv ^= BitVector( textstring = keyblock )                              #(Q)\\n\\n# Create a bitvector for storing the ciphertext bit array:\\nmsg_encrypted_bv = BitVector( size = 0 )                                      #(R)\\n\\n# Carry out differential XORing of bit blocks and encryption:\\nprevious_block = bv_iv                                                        #(S)\\nbv = BitVector( filename = sys.argv[1] )                                      #(T)\\nwhile (bv.more_to_read):                                                      #(U)\\n    bv_read = bv.read_bits_from_file(BLOCKSIZE)                               #(V)\\n    if len(bv_read) < BLOCKSIZE:                                              #(W)\\n        bv_read += BitVector(size = (BLOCKSIZE - len(bv_read)))               #(X)\\n    bv_read ^= key_bv                                                         #(Y)\\n    bv_read ^= previous_block                                                 #(Z)\\n    previous_block = bv_read.deep_copy()                                      #(a)\\n    msg_encrypted_bv += bv_read                                               #(b)\\n\\n# Convert the encrypted bitvector into a hex string:    \\noutputhex = msg_encrypted_bv.get_hex_string_from_bitvector()                  #(c)\\n\\n# Write ciphertext bitvector to the output file:\\nFILEOUT = open(sys.argv[2], 'w')                                              #(d)\\nFILEOUT.write(outputhex)                                                      #(e)\\nFILEOUT.close()                                                               #(f)\\n\"︡{\"metadata\":{\"collapsed\":false,\"trusted\":false},\"cell_type\":\"code\",\"execution_count\":null,\"outputs\":[]}"]],0,0,4380,0]],"time":1456664936726}